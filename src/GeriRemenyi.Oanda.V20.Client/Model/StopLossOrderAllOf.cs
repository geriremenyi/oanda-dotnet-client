/* 
 * OANDA v20 API
 *
 * The full OANDA v20 API Specification. This specification defines how to interact with v20 Accounts, Trades, Orders, Pricing and more.
 *
 * The version of the OpenAPI document: 3.0.25
 * Contact: api@oanda.com
 * Generated by: https://github.com/openapitools/openapi-generator.git
 */


using System;
using System.Linq;
using System.IO;
using System.Text;
using System.Text.RegularExpressions;
using System.Collections;
using System.Collections.Generic;
using System.Collections.ObjectModel;
using System.Runtime.Serialization;
using Newtonsoft.Json;
using Newtonsoft.Json.Converters;
using System.ComponentModel.DataAnnotations;
using OpenAPIDateConverter = GeriRemenyi.Oanda.V20.Client.Client.OpenAPIDateConverter;

namespace GeriRemenyi.Oanda.V20.Client.Model
{
    /// <summary>
    /// StopLossOrderAllOf
    /// </summary>
    [DataContract]
    public partial class StopLossOrderAllOf :  IEquatable<StopLossOrderAllOf>, IValidatableObject
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="StopLossOrderAllOf" /> class.
        /// </summary>
        /// <param name="price">The price threshold specified for the Stop Loss Order. If the guaranteed flag is false, the associated Trade will be closed by a market price that is equal to or worse than this threshold. If the flag is true the associated Trade will be closed at this price..</param>
        /// <param name="guaranteedExecutionPremium">The premium that will be charged if the Stop Loss Order is guaranteed and the Order is filled at the guaranteed price. It is in price units and is charged for each unit of the Trade..</param>
        /// <param name="distance">Specifies the distance (in price units) from the Account&#39;s current price to use as the Stop Loss Order price. If the Trade is short the Instrument&#39;s bid price is used, and for long Trades the ask is used..</param>
        /// <param name="guaranteed">Flag indicating that the Stop Loss Order is guaranteed. The default value depends on the GuaranteedStopLossOrderMode of the account, if it is REQUIRED, the default will be true, for DISABLED or ENABLED the default is false..</param>
        public StopLossOrderAllOf(double price = default(double), double guaranteedExecutionPremium = default(double), double distance = default(double), bool guaranteed = default(bool))
        {
            this.Price = price;
            this.GuaranteedExecutionPremium = guaranteedExecutionPremium;
            this.Distance = distance;
            this.Guaranteed = guaranteed;
        }
        
        /// <summary>
        /// The price threshold specified for the Stop Loss Order. If the guaranteed flag is false, the associated Trade will be closed by a market price that is equal to or worse than this threshold. If the flag is true the associated Trade will be closed at this price.
        /// </summary>
        /// <value>The price threshold specified for the Stop Loss Order. If the guaranteed flag is false, the associated Trade will be closed by a market price that is equal to or worse than this threshold. If the flag is true the associated Trade will be closed at this price.</value>
        [DataMember(Name="price", EmitDefaultValue=false)]
        public double Price { get; set; }

        /// <summary>
        /// The premium that will be charged if the Stop Loss Order is guaranteed and the Order is filled at the guaranteed price. It is in price units and is charged for each unit of the Trade.
        /// </summary>
        /// <value>The premium that will be charged if the Stop Loss Order is guaranteed and the Order is filled at the guaranteed price. It is in price units and is charged for each unit of the Trade.</value>
        [DataMember(Name="guaranteedExecutionPremium", EmitDefaultValue=false)]
        public double GuaranteedExecutionPremium { get; set; }

        /// <summary>
        /// Specifies the distance (in price units) from the Account&#39;s current price to use as the Stop Loss Order price. If the Trade is short the Instrument&#39;s bid price is used, and for long Trades the ask is used.
        /// </summary>
        /// <value>Specifies the distance (in price units) from the Account&#39;s current price to use as the Stop Loss Order price. If the Trade is short the Instrument&#39;s bid price is used, and for long Trades the ask is used.</value>
        [DataMember(Name="distance", EmitDefaultValue=false)]
        public double Distance { get; set; }

        /// <summary>
        /// Flag indicating that the Stop Loss Order is guaranteed. The default value depends on the GuaranteedStopLossOrderMode of the account, if it is REQUIRED, the default will be true, for DISABLED or ENABLED the default is false.
        /// </summary>
        /// <value>Flag indicating that the Stop Loss Order is guaranteed. The default value depends on the GuaranteedStopLossOrderMode of the account, if it is REQUIRED, the default will be true, for DISABLED or ENABLED the default is false.</value>
        [DataMember(Name="guaranteed", EmitDefaultValue=false)]
        public bool Guaranteed { get; set; }

        /// <summary>
        /// Returns the string presentation of the object
        /// </summary>
        /// <returns>String presentation of the object</returns>
        public override string ToString()
        {
            var sb = new StringBuilder();
            sb.Append("class StopLossOrderAllOf {\n");
            sb.Append("  Price: ").Append(Price).Append("\n");
            sb.Append("  GuaranteedExecutionPremium: ").Append(GuaranteedExecutionPremium).Append("\n");
            sb.Append("  Distance: ").Append(Distance).Append("\n");
            sb.Append("  Guaranteed: ").Append(Guaranteed).Append("\n");
            sb.Append("}\n");
            return sb.ToString();
        }
  
        /// <summary>
        /// Returns the JSON string presentation of the object
        /// </summary>
        /// <returns>JSON string presentation of the object</returns>
        public virtual string ToJson()
        {
            return JsonConvert.SerializeObject(this, Formatting.Indented);
        }

        /// <summary>
        /// Returns true if objects are equal
        /// </summary>
        /// <param name="input">Object to be compared</param>
        /// <returns>Boolean</returns>
        public override bool Equals(object input)
        {
            return this.Equals(input as StopLossOrderAllOf);
        }

        /// <summary>
        /// Returns true if StopLossOrderAllOf instances are equal
        /// </summary>
        /// <param name="input">Instance of StopLossOrderAllOf to be compared</param>
        /// <returns>Boolean</returns>
        public bool Equals(StopLossOrderAllOf input)
        {
            if (input == null)
                return false;

            return 
                (
                    this.Price == input.Price ||
                    this.Price.Equals(input.Price)
                ) && 
                (
                    this.GuaranteedExecutionPremium == input.GuaranteedExecutionPremium ||
                    this.GuaranteedExecutionPremium.Equals(input.GuaranteedExecutionPremium)
                ) && 
                (
                    this.Distance == input.Distance ||
                    this.Distance.Equals(input.Distance)
                ) && 
                (
                    this.Guaranteed == input.Guaranteed ||
                    this.Guaranteed.Equals(input.Guaranteed)
                );
        }

        /// <summary>
        /// Gets the hash code
        /// </summary>
        /// <returns>Hash code</returns>
        public override int GetHashCode()
        {
            unchecked // Overflow is fine, just wrap
            {
                int hashCode = 41;
                hashCode = hashCode * 59 + this.Price.GetHashCode();
                hashCode = hashCode * 59 + this.GuaranteedExecutionPremium.GetHashCode();
                hashCode = hashCode * 59 + this.Distance.GetHashCode();
                hashCode = hashCode * 59 + this.Guaranteed.GetHashCode();
                return hashCode;
            }
        }

        /// <summary>
        /// To validate all properties of the instance
        /// </summary>
        /// <param name="validationContext">Validation context</param>
        /// <returns>Validation Result</returns>
        IEnumerable<System.ComponentModel.DataAnnotations.ValidationResult> IValidatableObject.Validate(ValidationContext validationContext)
        {
            yield break;
        }
    }

}
