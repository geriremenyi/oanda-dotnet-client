/* 
 * OANDA v20 API
 *
 * The full OANDA v20 API Specification. This specification defines how to interact with v20 Accounts, Trades, Orders, Pricing and more.
 *
 * The version of the OpenAPI document: 3.0.25
 * Contact: api@oanda.com
 * Generated by: https://github.com/openapitools/openapi-generator.git
 */


using System;
using System.Collections.Generic;
using System.Collections.ObjectModel;
using System.Linq;
using System.Net;
using System.Net.Mime;
using GeriRemenyi.Oanda.V20.Client.Client;
using GeriRemenyi.Oanda.V20.Client.Model;

namespace GeriRemenyi.Oanda.V20.Client.Api
{

    /// <summary>
    /// Represents a collection of functions to interact with the API endpoints
    /// </summary>
    public interface IInstrumentApiSync : IApiAccessor
    {
        #region Synchronous Operations
        /// <summary>
        /// Get Candlesticks
        /// </summary>
        /// <remarks>
        /// Fetch candlestick data for an instrument.
        /// </remarks>
        /// <exception cref="GeriRemenyi.Oanda.V20.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="instrument">Instrument name</param>
        /// <param name="acceptDatetimeFormat">Format of DateTime fields in the request and response. (optional)</param>
        /// <param name="price">The Price component(s) to get candlestick data for. Can contain any combination of the characters \&quot;M\&quot; (midpoint candles) \&quot;B\&quot; (bid candles) and \&quot;A\&quot; (ask candles). (optional)</param>
        /// <param name="granularity">The granularity of the candlesticks to fetch (optional)</param>
        /// <param name="count">The number of candlesticks to return in the reponse. Count should not be specified if both the start and end parameters are provided, as the time range combined with the graularity will determine the number of candlesticks to return. (optional)</param>
        /// <param name="from">The start of the time range to fetch candlesticks for. (optional)</param>
        /// <param name="to">The end of the time range to fetch candlesticks for. (optional)</param>
        /// <param name="smooth">A flag that controls whether the candlestick is \&quot;smoothed\&quot; or not.  A smoothed candlestick uses the previous candle&#39;s close price as its open price, while an unsmoothed candlestick uses the first price from its time range as its open price. (optional)</param>
        /// <param name="includeFirst">A flag that controls whether the candlestick that is covered by the from time should be included in the results. This flag enables clients to use the timestamp of the last completed candlestick received to poll for future candlesticks but avoid receiving the previous candlestick repeatedly. (optional)</param>
        /// <param name="dailyAlignment">The hour of the day (in the specified timezone) to use for granularities that have daily alignments. (optional)</param>
        /// <param name="alignmentTimezone">The timezone to use for the dailyAlignment parameter. Candlesticks with daily alignment will be aligned to the dailyAlignment hour within the alignmentTimezone.  Note that the returned times will still be represented in UTC. (optional)</param>
        /// <param name="weeklyAlignment">The day of the week used for granularities that have weekly alignment. (optional)</param>
        /// <returns>CandlesResponse</returns>
        CandlesResponse GetInstrumentCandles (InstrumentName instrument, DateTimeFormat? acceptDatetimeFormat = default(DateTimeFormat?), string price = default(string), CandlestickGranularity? granularity = default(CandlestickGranularity?), int? count = default(int?), string from = default(string), string to = default(string), bool? smooth = default(bool?), bool? includeFirst = default(bool?), int? dailyAlignment = default(int?), string alignmentTimezone = default(string), string weeklyAlignment = default(string));

        /// <summary>
        /// Get Candlesticks
        /// </summary>
        /// <remarks>
        /// Fetch candlestick data for an instrument.
        /// </remarks>
        /// <exception cref="GeriRemenyi.Oanda.V20.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="instrument">Instrument name</param>
        /// <param name="acceptDatetimeFormat">Format of DateTime fields in the request and response. (optional)</param>
        /// <param name="price">The Price component(s) to get candlestick data for. Can contain any combination of the characters \&quot;M\&quot; (midpoint candles) \&quot;B\&quot; (bid candles) and \&quot;A\&quot; (ask candles). (optional)</param>
        /// <param name="granularity">The granularity of the candlesticks to fetch (optional)</param>
        /// <param name="count">The number of candlesticks to return in the reponse. Count should not be specified if both the start and end parameters are provided, as the time range combined with the graularity will determine the number of candlesticks to return. (optional)</param>
        /// <param name="from">The start of the time range to fetch candlesticks for. (optional)</param>
        /// <param name="to">The end of the time range to fetch candlesticks for. (optional)</param>
        /// <param name="smooth">A flag that controls whether the candlestick is \&quot;smoothed\&quot; or not.  A smoothed candlestick uses the previous candle&#39;s close price as its open price, while an unsmoothed candlestick uses the first price from its time range as its open price. (optional)</param>
        /// <param name="includeFirst">A flag that controls whether the candlestick that is covered by the from time should be included in the results. This flag enables clients to use the timestamp of the last completed candlestick received to poll for future candlesticks but avoid receiving the previous candlestick repeatedly. (optional)</param>
        /// <param name="dailyAlignment">The hour of the day (in the specified timezone) to use for granularities that have daily alignments. (optional)</param>
        /// <param name="alignmentTimezone">The timezone to use for the dailyAlignment parameter. Candlesticks with daily alignment will be aligned to the dailyAlignment hour within the alignmentTimezone.  Note that the returned times will still be represented in UTC. (optional)</param>
        /// <param name="weeklyAlignment">The day of the week used for granularities that have weekly alignment. (optional)</param>
        /// <returns>ApiResponse of CandlesResponse</returns>
        ApiResponse<CandlesResponse> GetInstrumentCandlesWithHttpInfo (InstrumentName instrument, DateTimeFormat? acceptDatetimeFormat = default(DateTimeFormat?), string price = default(string), CandlestickGranularity? granularity = default(CandlestickGranularity?), int? count = default(int?), string from = default(string), string to = default(string), bool? smooth = default(bool?), bool? includeFirst = default(bool?), int? dailyAlignment = default(int?), string alignmentTimezone = default(string), string weeklyAlignment = default(string));
        /// <summary>
        /// Get Order Book
        /// </summary>
        /// <remarks>
        /// Fetch an order book for an instrument.
        /// </remarks>
        /// <exception cref="GeriRemenyi.Oanda.V20.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="instrument">Instrument name</param>
        /// <param name="acceptDatetimeFormat">Format of DateTime fields in the request and response. (optional)</param>
        /// <param name="time">The time of the snapshot to fetch. If not specified, then the most recent snapshot is fetched. (optional)</param>
        /// <returns>InstrumentOrderBookResponse</returns>
        InstrumentOrderBookResponse GetInstrumentOrderBook (InstrumentName instrument, DateTimeFormat? acceptDatetimeFormat = default(DateTimeFormat?), string time = default(string));

        /// <summary>
        /// Get Order Book
        /// </summary>
        /// <remarks>
        /// Fetch an order book for an instrument.
        /// </remarks>
        /// <exception cref="GeriRemenyi.Oanda.V20.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="instrument">Instrument name</param>
        /// <param name="acceptDatetimeFormat">Format of DateTime fields in the request and response. (optional)</param>
        /// <param name="time">The time of the snapshot to fetch. If not specified, then the most recent snapshot is fetched. (optional)</param>
        /// <returns>ApiResponse of InstrumentOrderBookResponse</returns>
        ApiResponse<InstrumentOrderBookResponse> GetInstrumentOrderBookWithHttpInfo (InstrumentName instrument, DateTimeFormat? acceptDatetimeFormat = default(DateTimeFormat?), string time = default(string));
        /// <summary>
        /// Get Position Book
        /// </summary>
        /// <remarks>
        /// Fetch a position book for an instrument.
        /// </remarks>
        /// <exception cref="GeriRemenyi.Oanda.V20.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="instrument">Instrument name</param>
        /// <param name="acceptDatetimeFormat">Format of DateTime fields in the request and response. (optional)</param>
        /// <param name="time">The time of the snapshot to fetch. If not specified, then the most recent snapshot is fetched. (optional)</param>
        /// <returns>InstrumentPositionBookResponse</returns>
        InstrumentPositionBookResponse GetInstrumentPositionBook (InstrumentName instrument, DateTimeFormat? acceptDatetimeFormat = default(DateTimeFormat?), string time = default(string));

        /// <summary>
        /// Get Position Book
        /// </summary>
        /// <remarks>
        /// Fetch a position book for an instrument.
        /// </remarks>
        /// <exception cref="GeriRemenyi.Oanda.V20.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="instrument">Instrument name</param>
        /// <param name="acceptDatetimeFormat">Format of DateTime fields in the request and response. (optional)</param>
        /// <param name="time">The time of the snapshot to fetch. If not specified, then the most recent snapshot is fetched. (optional)</param>
        /// <returns>ApiResponse of InstrumentPositionBookResponse</returns>
        ApiResponse<InstrumentPositionBookResponse> GetInstrumentPositionBookWithHttpInfo (InstrumentName instrument, DateTimeFormat? acceptDatetimeFormat = default(DateTimeFormat?), string time = default(string));
        #endregion Synchronous Operations
    }

    /// <summary>
    /// Represents a collection of functions to interact with the API endpoints
    /// </summary>
    public interface IInstrumentApiAsync : IApiAccessor
    {
        #region Asynchronous Operations
        /// <summary>
        /// Get Candlesticks
        /// </summary>
        /// <remarks>
        /// Fetch candlestick data for an instrument.
        /// </remarks>
        /// <exception cref="GeriRemenyi.Oanda.V20.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="instrument">Instrument name</param>
        /// <param name="acceptDatetimeFormat">Format of DateTime fields in the request and response. (optional)</param>
        /// <param name="price">The Price component(s) to get candlestick data for. Can contain any combination of the characters \&quot;M\&quot; (midpoint candles) \&quot;B\&quot; (bid candles) and \&quot;A\&quot; (ask candles). (optional)</param>
        /// <param name="granularity">The granularity of the candlesticks to fetch (optional)</param>
        /// <param name="count">The number of candlesticks to return in the reponse. Count should not be specified if both the start and end parameters are provided, as the time range combined with the graularity will determine the number of candlesticks to return. (optional)</param>
        /// <param name="from">The start of the time range to fetch candlesticks for. (optional)</param>
        /// <param name="to">The end of the time range to fetch candlesticks for. (optional)</param>
        /// <param name="smooth">A flag that controls whether the candlestick is \&quot;smoothed\&quot; or not.  A smoothed candlestick uses the previous candle&#39;s close price as its open price, while an unsmoothed candlestick uses the first price from its time range as its open price. (optional)</param>
        /// <param name="includeFirst">A flag that controls whether the candlestick that is covered by the from time should be included in the results. This flag enables clients to use the timestamp of the last completed candlestick received to poll for future candlesticks but avoid receiving the previous candlestick repeatedly. (optional)</param>
        /// <param name="dailyAlignment">The hour of the day (in the specified timezone) to use for granularities that have daily alignments. (optional)</param>
        /// <param name="alignmentTimezone">The timezone to use for the dailyAlignment parameter. Candlesticks with daily alignment will be aligned to the dailyAlignment hour within the alignmentTimezone.  Note that the returned times will still be represented in UTC. (optional)</param>
        /// <param name="weeklyAlignment">The day of the week used for granularities that have weekly alignment. (optional)</param>
        /// <returns>Task of CandlesResponse</returns>
        System.Threading.Tasks.Task<CandlesResponse> GetInstrumentCandlesAsync (InstrumentName instrument, DateTimeFormat? acceptDatetimeFormat = default(DateTimeFormat?), string price = default(string), CandlestickGranularity? granularity = default(CandlestickGranularity?), int? count = default(int?), string from = default(string), string to = default(string), bool? smooth = default(bool?), bool? includeFirst = default(bool?), int? dailyAlignment = default(int?), string alignmentTimezone = default(string), string weeklyAlignment = default(string));

        /// <summary>
        /// Get Candlesticks
        /// </summary>
        /// <remarks>
        /// Fetch candlestick data for an instrument.
        /// </remarks>
        /// <exception cref="GeriRemenyi.Oanda.V20.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="instrument">Instrument name</param>
        /// <param name="acceptDatetimeFormat">Format of DateTime fields in the request and response. (optional)</param>
        /// <param name="price">The Price component(s) to get candlestick data for. Can contain any combination of the characters \&quot;M\&quot; (midpoint candles) \&quot;B\&quot; (bid candles) and \&quot;A\&quot; (ask candles). (optional)</param>
        /// <param name="granularity">The granularity of the candlesticks to fetch (optional)</param>
        /// <param name="count">The number of candlesticks to return in the reponse. Count should not be specified if both the start and end parameters are provided, as the time range combined with the graularity will determine the number of candlesticks to return. (optional)</param>
        /// <param name="from">The start of the time range to fetch candlesticks for. (optional)</param>
        /// <param name="to">The end of the time range to fetch candlesticks for. (optional)</param>
        /// <param name="smooth">A flag that controls whether the candlestick is \&quot;smoothed\&quot; or not.  A smoothed candlestick uses the previous candle&#39;s close price as its open price, while an unsmoothed candlestick uses the first price from its time range as its open price. (optional)</param>
        /// <param name="includeFirst">A flag that controls whether the candlestick that is covered by the from time should be included in the results. This flag enables clients to use the timestamp of the last completed candlestick received to poll for future candlesticks but avoid receiving the previous candlestick repeatedly. (optional)</param>
        /// <param name="dailyAlignment">The hour of the day (in the specified timezone) to use for granularities that have daily alignments. (optional)</param>
        /// <param name="alignmentTimezone">The timezone to use for the dailyAlignment parameter. Candlesticks with daily alignment will be aligned to the dailyAlignment hour within the alignmentTimezone.  Note that the returned times will still be represented in UTC. (optional)</param>
        /// <param name="weeklyAlignment">The day of the week used for granularities that have weekly alignment. (optional)</param>
        /// <returns>Task of ApiResponse (CandlesResponse)</returns>
        System.Threading.Tasks.Task<ApiResponse<CandlesResponse>> GetInstrumentCandlesAsyncWithHttpInfo (InstrumentName instrument, DateTimeFormat? acceptDatetimeFormat = default(DateTimeFormat?), string price = default(string), CandlestickGranularity? granularity = default(CandlestickGranularity?), int? count = default(int?), string from = default(string), string to = default(string), bool? smooth = default(bool?), bool? includeFirst = default(bool?), int? dailyAlignment = default(int?), string alignmentTimezone = default(string), string weeklyAlignment = default(string));
        /// <summary>
        /// Get Order Book
        /// </summary>
        /// <remarks>
        /// Fetch an order book for an instrument.
        /// </remarks>
        /// <exception cref="GeriRemenyi.Oanda.V20.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="instrument">Instrument name</param>
        /// <param name="acceptDatetimeFormat">Format of DateTime fields in the request and response. (optional)</param>
        /// <param name="time">The time of the snapshot to fetch. If not specified, then the most recent snapshot is fetched. (optional)</param>
        /// <returns>Task of InstrumentOrderBookResponse</returns>
        System.Threading.Tasks.Task<InstrumentOrderBookResponse> GetInstrumentOrderBookAsync (InstrumentName instrument, DateTimeFormat? acceptDatetimeFormat = default(DateTimeFormat?), string time = default(string));

        /// <summary>
        /// Get Order Book
        /// </summary>
        /// <remarks>
        /// Fetch an order book for an instrument.
        /// </remarks>
        /// <exception cref="GeriRemenyi.Oanda.V20.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="instrument">Instrument name</param>
        /// <param name="acceptDatetimeFormat">Format of DateTime fields in the request and response. (optional)</param>
        /// <param name="time">The time of the snapshot to fetch. If not specified, then the most recent snapshot is fetched. (optional)</param>
        /// <returns>Task of ApiResponse (InstrumentOrderBookResponse)</returns>
        System.Threading.Tasks.Task<ApiResponse<InstrumentOrderBookResponse>> GetInstrumentOrderBookAsyncWithHttpInfo (InstrumentName instrument, DateTimeFormat? acceptDatetimeFormat = default(DateTimeFormat?), string time = default(string));
        /// <summary>
        /// Get Position Book
        /// </summary>
        /// <remarks>
        /// Fetch a position book for an instrument.
        /// </remarks>
        /// <exception cref="GeriRemenyi.Oanda.V20.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="instrument">Instrument name</param>
        /// <param name="acceptDatetimeFormat">Format of DateTime fields in the request and response. (optional)</param>
        /// <param name="time">The time of the snapshot to fetch. If not specified, then the most recent snapshot is fetched. (optional)</param>
        /// <returns>Task of InstrumentPositionBookResponse</returns>
        System.Threading.Tasks.Task<InstrumentPositionBookResponse> GetInstrumentPositionBookAsync (InstrumentName instrument, DateTimeFormat? acceptDatetimeFormat = default(DateTimeFormat?), string time = default(string));

        /// <summary>
        /// Get Position Book
        /// </summary>
        /// <remarks>
        /// Fetch a position book for an instrument.
        /// </remarks>
        /// <exception cref="GeriRemenyi.Oanda.V20.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="instrument">Instrument name</param>
        /// <param name="acceptDatetimeFormat">Format of DateTime fields in the request and response. (optional)</param>
        /// <param name="time">The time of the snapshot to fetch. If not specified, then the most recent snapshot is fetched. (optional)</param>
        /// <returns>Task of ApiResponse (InstrumentPositionBookResponse)</returns>
        System.Threading.Tasks.Task<ApiResponse<InstrumentPositionBookResponse>> GetInstrumentPositionBookAsyncWithHttpInfo (InstrumentName instrument, DateTimeFormat? acceptDatetimeFormat = default(DateTimeFormat?), string time = default(string));
        #endregion Asynchronous Operations
    }

    /// <summary>
    /// Represents a collection of functions to interact with the API endpoints
    /// </summary>
    public interface IInstrumentApi : IInstrumentApiSync, IInstrumentApiAsync
    {

    }

    /// <summary>
    /// Represents a collection of functions to interact with the API endpoints
    /// </summary>
    public partial class InstrumentApi : IInstrumentApi
    {
        private GeriRemenyi.Oanda.V20.Client.Client.ExceptionFactory _exceptionFactory = (name, response) => null;

        /// <summary>
        /// Initializes a new instance of the <see cref="InstrumentApi"/> class.
        /// </summary>
        /// <returns></returns>
        public InstrumentApi() : this((string) null)
        {
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="InstrumentApi"/> class.
        /// </summary>
        /// <returns></returns>
        public InstrumentApi(String basePath)
        {
            this.Configuration = GeriRemenyi.Oanda.V20.Client.Client.Configuration.MergeConfigurations(
                GeriRemenyi.Oanda.V20.Client.Client.GlobalConfiguration.Instance,
                new GeriRemenyi.Oanda.V20.Client.Client.Configuration { BasePath = basePath }
            );
            this.Client = new GeriRemenyi.Oanda.V20.Client.Client.ApiClient(this.Configuration.BasePath);
            this.AsynchronousClient = new GeriRemenyi.Oanda.V20.Client.Client.ApiClient(this.Configuration.BasePath);
            this.ExceptionFactory = GeriRemenyi.Oanda.V20.Client.Client.Configuration.DefaultExceptionFactory;
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="InstrumentApi"/> class
        /// using Configuration object
        /// </summary>
        /// <param name="configuration">An instance of Configuration</param>
        /// <returns></returns>
        public InstrumentApi(GeriRemenyi.Oanda.V20.Client.Client.Configuration configuration)
        {
            if (configuration == null) throw new ArgumentNullException("configuration");

            this.Configuration = GeriRemenyi.Oanda.V20.Client.Client.Configuration.MergeConfigurations(
                GeriRemenyi.Oanda.V20.Client.Client.GlobalConfiguration.Instance,
                configuration
            );
            this.Client = new GeriRemenyi.Oanda.V20.Client.Client.ApiClient(this.Configuration.BasePath);
            this.AsynchronousClient = new GeriRemenyi.Oanda.V20.Client.Client.ApiClient(this.Configuration.BasePath);
            ExceptionFactory = GeriRemenyi.Oanda.V20.Client.Client.Configuration.DefaultExceptionFactory;
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="InstrumentApi"/> class
        /// using a Configuration object and client instance.
        /// </summary>
        /// <param name="client">The client interface for synchronous API access.</param>
        /// <param name="asyncClient">The client interface for asynchronous API access.</param>
        /// <param name="configuration">The configuration object.</param>
        public InstrumentApi(GeriRemenyi.Oanda.V20.Client.Client.ISynchronousClient client,GeriRemenyi.Oanda.V20.Client.Client.IAsynchronousClient asyncClient, GeriRemenyi.Oanda.V20.Client.Client.IReadableConfiguration configuration)
        {
            if(client == null) throw new ArgumentNullException("client");
            if(asyncClient == null) throw new ArgumentNullException("asyncClient");
            if(configuration == null) throw new ArgumentNullException("configuration");

            this.Client = client;
            this.AsynchronousClient = asyncClient;
            this.Configuration = configuration;
            this.ExceptionFactory = GeriRemenyi.Oanda.V20.Client.Client.Configuration.DefaultExceptionFactory;
        }

        /// <summary>
        /// The client for accessing this underlying API asynchronously.
        /// </summary>
        public GeriRemenyi.Oanda.V20.Client.Client.IAsynchronousClient AsynchronousClient { get; set; }

        /// <summary>
        /// The client for accessing this underlying API synchronously.
        /// </summary>
        public GeriRemenyi.Oanda.V20.Client.Client.ISynchronousClient Client { get; set; }

        /// <summary>
        /// Gets the base path of the API client.
        /// </summary>
        /// <value>The base path</value>
        public String GetBasePath()
        {
            return this.Configuration.BasePath;
        }

        /// <summary>
        /// Gets or sets the configuration object
        /// </summary>
        /// <value>An instance of the Configuration</value>
        public GeriRemenyi.Oanda.V20.Client.Client.IReadableConfiguration Configuration {get; set;}

        /// <summary>
        /// Provides a factory method hook for the creation of exceptions.
        /// </summary>
        public GeriRemenyi.Oanda.V20.Client.Client.ExceptionFactory ExceptionFactory
        {
            get
            {
                if (_exceptionFactory != null && _exceptionFactory.GetInvocationList().Length > 1)
                {
                    throw new InvalidOperationException("Multicast delegate for ExceptionFactory is unsupported.");
                }
                return _exceptionFactory;
            }
            set { _exceptionFactory = value; }
        }

        /// <summary>
        /// Get Candlesticks Fetch candlestick data for an instrument.
        /// </summary>
        /// <exception cref="GeriRemenyi.Oanda.V20.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="instrument">Instrument name</param>
        /// <param name="acceptDatetimeFormat">Format of DateTime fields in the request and response. (optional)</param>
        /// <param name="price">The Price component(s) to get candlestick data for. Can contain any combination of the characters \&quot;M\&quot; (midpoint candles) \&quot;B\&quot; (bid candles) and \&quot;A\&quot; (ask candles). (optional)</param>
        /// <param name="granularity">The granularity of the candlesticks to fetch (optional)</param>
        /// <param name="count">The number of candlesticks to return in the reponse. Count should not be specified if both the start and end parameters are provided, as the time range combined with the graularity will determine the number of candlesticks to return. (optional)</param>
        /// <param name="from">The start of the time range to fetch candlesticks for. (optional)</param>
        /// <param name="to">The end of the time range to fetch candlesticks for. (optional)</param>
        /// <param name="smooth">A flag that controls whether the candlestick is \&quot;smoothed\&quot; or not.  A smoothed candlestick uses the previous candle&#39;s close price as its open price, while an unsmoothed candlestick uses the first price from its time range as its open price. (optional)</param>
        /// <param name="includeFirst">A flag that controls whether the candlestick that is covered by the from time should be included in the results. This flag enables clients to use the timestamp of the last completed candlestick received to poll for future candlesticks but avoid receiving the previous candlestick repeatedly. (optional)</param>
        /// <param name="dailyAlignment">The hour of the day (in the specified timezone) to use for granularities that have daily alignments. (optional)</param>
        /// <param name="alignmentTimezone">The timezone to use for the dailyAlignment parameter. Candlesticks with daily alignment will be aligned to the dailyAlignment hour within the alignmentTimezone.  Note that the returned times will still be represented in UTC. (optional)</param>
        /// <param name="weeklyAlignment">The day of the week used for granularities that have weekly alignment. (optional)</param>
        /// <returns>CandlesResponse</returns>
        public CandlesResponse GetInstrumentCandles (InstrumentName instrument, DateTimeFormat? acceptDatetimeFormat = default(DateTimeFormat?), string price = default(string), CandlestickGranularity? granularity = default(CandlestickGranularity?), int? count = default(int?), string from = default(string), string to = default(string), bool? smooth = default(bool?), bool? includeFirst = default(bool?), int? dailyAlignment = default(int?), string alignmentTimezone = default(string), string weeklyAlignment = default(string))
        {
             GeriRemenyi.Oanda.V20.Client.Client.ApiResponse<CandlesResponse> localVarResponse = GetInstrumentCandlesWithHttpInfo(instrument, acceptDatetimeFormat, price, granularity, count, from, to, smooth, includeFirst, dailyAlignment, alignmentTimezone, weeklyAlignment);
             return localVarResponse.Data;
        }

        /// <summary>
        /// Get Candlesticks Fetch candlestick data for an instrument.
        /// </summary>
        /// <exception cref="GeriRemenyi.Oanda.V20.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="instrument">Instrument name</param>
        /// <param name="acceptDatetimeFormat">Format of DateTime fields in the request and response. (optional)</param>
        /// <param name="price">The Price component(s) to get candlestick data for. Can contain any combination of the characters \&quot;M\&quot; (midpoint candles) \&quot;B\&quot; (bid candles) and \&quot;A\&quot; (ask candles). (optional)</param>
        /// <param name="granularity">The granularity of the candlesticks to fetch (optional)</param>
        /// <param name="count">The number of candlesticks to return in the reponse. Count should not be specified if both the start and end parameters are provided, as the time range combined with the graularity will determine the number of candlesticks to return. (optional)</param>
        /// <param name="from">The start of the time range to fetch candlesticks for. (optional)</param>
        /// <param name="to">The end of the time range to fetch candlesticks for. (optional)</param>
        /// <param name="smooth">A flag that controls whether the candlestick is \&quot;smoothed\&quot; or not.  A smoothed candlestick uses the previous candle&#39;s close price as its open price, while an unsmoothed candlestick uses the first price from its time range as its open price. (optional)</param>
        /// <param name="includeFirst">A flag that controls whether the candlestick that is covered by the from time should be included in the results. This flag enables clients to use the timestamp of the last completed candlestick received to poll for future candlesticks but avoid receiving the previous candlestick repeatedly. (optional)</param>
        /// <param name="dailyAlignment">The hour of the day (in the specified timezone) to use for granularities that have daily alignments. (optional)</param>
        /// <param name="alignmentTimezone">The timezone to use for the dailyAlignment parameter. Candlesticks with daily alignment will be aligned to the dailyAlignment hour within the alignmentTimezone.  Note that the returned times will still be represented in UTC. (optional)</param>
        /// <param name="weeklyAlignment">The day of the week used for granularities that have weekly alignment. (optional)</param>
        /// <returns>ApiResponse of CandlesResponse</returns>
        public GeriRemenyi.Oanda.V20.Client.Client.ApiResponse< CandlesResponse > GetInstrumentCandlesWithHttpInfo (InstrumentName instrument, DateTimeFormat? acceptDatetimeFormat = default(DateTimeFormat?), string price = default(string), CandlestickGranularity? granularity = default(CandlestickGranularity?), int? count = default(int?), string from = default(string), string to = default(string), bool? smooth = default(bool?), bool? includeFirst = default(bool?), int? dailyAlignment = default(int?), string alignmentTimezone = default(string), string weeklyAlignment = default(string))
        {
            GeriRemenyi.Oanda.V20.Client.Client.RequestOptions localVarRequestOptions = new GeriRemenyi.Oanda.V20.Client.Client.RequestOptions();

            String[] _contentTypes = new String[] {
            };

            // to determine the Accept header
            String[] _accepts = new String[] {
                "application/json"
            };

            var localVarContentType = GeriRemenyi.Oanda.V20.Client.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = GeriRemenyi.Oanda.V20.Client.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            localVarRequestOptions.PathParameters.Add("instrument", GeriRemenyi.Oanda.V20.Client.Client.ClientUtils.ParameterToString(instrument)); // path parameter
            if (price != null)
            {
                localVarRequestOptions.QueryParameters.Add(GeriRemenyi.Oanda.V20.Client.Client.ClientUtils.ParameterToMultiMap("", "price", price));
            }
            if (granularity != null)
            {
                localVarRequestOptions.QueryParameters.Add(GeriRemenyi.Oanda.V20.Client.Client.ClientUtils.ParameterToMultiMap("", "granularity", granularity));
            }
            if (count != null)
            {
                localVarRequestOptions.QueryParameters.Add(GeriRemenyi.Oanda.V20.Client.Client.ClientUtils.ParameterToMultiMap("", "count", count));
            }
            if (from != null)
            {
                localVarRequestOptions.QueryParameters.Add(GeriRemenyi.Oanda.V20.Client.Client.ClientUtils.ParameterToMultiMap("", "from", from));
            }
            if (to != null)
            {
                localVarRequestOptions.QueryParameters.Add(GeriRemenyi.Oanda.V20.Client.Client.ClientUtils.ParameterToMultiMap("", "to", to));
            }
            if (smooth != null)
            {
                localVarRequestOptions.QueryParameters.Add(GeriRemenyi.Oanda.V20.Client.Client.ClientUtils.ParameterToMultiMap("", "smooth", smooth));
            }
            if (includeFirst != null)
            {
                localVarRequestOptions.QueryParameters.Add(GeriRemenyi.Oanda.V20.Client.Client.ClientUtils.ParameterToMultiMap("", "includeFirst", includeFirst));
            }
            if (dailyAlignment != null)
            {
                localVarRequestOptions.QueryParameters.Add(GeriRemenyi.Oanda.V20.Client.Client.ClientUtils.ParameterToMultiMap("", "dailyAlignment", dailyAlignment));
            }
            if (alignmentTimezone != null)
            {
                localVarRequestOptions.QueryParameters.Add(GeriRemenyi.Oanda.V20.Client.Client.ClientUtils.ParameterToMultiMap("", "alignmentTimezone", alignmentTimezone));
            }
            if (weeklyAlignment != null)
            {
                localVarRequestOptions.QueryParameters.Add(GeriRemenyi.Oanda.V20.Client.Client.ClientUtils.ParameterToMultiMap("", "weeklyAlignment", weeklyAlignment));
            }
            if (acceptDatetimeFormat != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept-Datetime-Format", GeriRemenyi.Oanda.V20.Client.Client.ClientUtils.ParameterToString(acceptDatetimeFormat)); // header parameter
            }

            // authentication (PersonalAccessToken) required
            // bearer authentication required
            if (!String.IsNullOrEmpty(this.Configuration.AccessToken))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", "Bearer " + this.Configuration.AccessToken);
            }

            // make the HTTP request
            var localVarResponse = this.Client.Get< CandlesResponse >("/instruments/{instrument}/candles", localVarRequestOptions, this.Configuration);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("GetInstrumentCandles", localVarResponse);
                if (_exception != null) throw _exception;
            }

            return localVarResponse;
        }

        /// <summary>
        /// Get Candlesticks Fetch candlestick data for an instrument.
        /// </summary>
        /// <exception cref="GeriRemenyi.Oanda.V20.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="instrument">Instrument name</param>
        /// <param name="acceptDatetimeFormat">Format of DateTime fields in the request and response. (optional)</param>
        /// <param name="price">The Price component(s) to get candlestick data for. Can contain any combination of the characters \&quot;M\&quot; (midpoint candles) \&quot;B\&quot; (bid candles) and \&quot;A\&quot; (ask candles). (optional)</param>
        /// <param name="granularity">The granularity of the candlesticks to fetch (optional)</param>
        /// <param name="count">The number of candlesticks to return in the reponse. Count should not be specified if both the start and end parameters are provided, as the time range combined with the graularity will determine the number of candlesticks to return. (optional)</param>
        /// <param name="from">The start of the time range to fetch candlesticks for. (optional)</param>
        /// <param name="to">The end of the time range to fetch candlesticks for. (optional)</param>
        /// <param name="smooth">A flag that controls whether the candlestick is \&quot;smoothed\&quot; or not.  A smoothed candlestick uses the previous candle&#39;s close price as its open price, while an unsmoothed candlestick uses the first price from its time range as its open price. (optional)</param>
        /// <param name="includeFirst">A flag that controls whether the candlestick that is covered by the from time should be included in the results. This flag enables clients to use the timestamp of the last completed candlestick received to poll for future candlesticks but avoid receiving the previous candlestick repeatedly. (optional)</param>
        /// <param name="dailyAlignment">The hour of the day (in the specified timezone) to use for granularities that have daily alignments. (optional)</param>
        /// <param name="alignmentTimezone">The timezone to use for the dailyAlignment parameter. Candlesticks with daily alignment will be aligned to the dailyAlignment hour within the alignmentTimezone.  Note that the returned times will still be represented in UTC. (optional)</param>
        /// <param name="weeklyAlignment">The day of the week used for granularities that have weekly alignment. (optional)</param>
        /// <returns>Task of CandlesResponse</returns>
        public async System.Threading.Tasks.Task<CandlesResponse> GetInstrumentCandlesAsync (InstrumentName instrument, DateTimeFormat? acceptDatetimeFormat = default(DateTimeFormat?), string price = default(string), CandlestickGranularity? granularity = default(CandlestickGranularity?), int? count = default(int?), string from = default(string), string to = default(string), bool? smooth = default(bool?), bool? includeFirst = default(bool?), int? dailyAlignment = default(int?), string alignmentTimezone = default(string), string weeklyAlignment = default(string))
        {
             GeriRemenyi.Oanda.V20.Client.Client.ApiResponse<CandlesResponse> localVarResponse = await GetInstrumentCandlesAsyncWithHttpInfo(instrument, acceptDatetimeFormat, price, granularity, count, from, to, smooth, includeFirst, dailyAlignment, alignmentTimezone, weeklyAlignment);
             return localVarResponse.Data;

        }

        /// <summary>
        /// Get Candlesticks Fetch candlestick data for an instrument.
        /// </summary>
        /// <exception cref="GeriRemenyi.Oanda.V20.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="instrument">Instrument name</param>
        /// <param name="acceptDatetimeFormat">Format of DateTime fields in the request and response. (optional)</param>
        /// <param name="price">The Price component(s) to get candlestick data for. Can contain any combination of the characters \&quot;M\&quot; (midpoint candles) \&quot;B\&quot; (bid candles) and \&quot;A\&quot; (ask candles). (optional)</param>
        /// <param name="granularity">The granularity of the candlesticks to fetch (optional)</param>
        /// <param name="count">The number of candlesticks to return in the reponse. Count should not be specified if both the start and end parameters are provided, as the time range combined with the graularity will determine the number of candlesticks to return. (optional)</param>
        /// <param name="from">The start of the time range to fetch candlesticks for. (optional)</param>
        /// <param name="to">The end of the time range to fetch candlesticks for. (optional)</param>
        /// <param name="smooth">A flag that controls whether the candlestick is \&quot;smoothed\&quot; or not.  A smoothed candlestick uses the previous candle&#39;s close price as its open price, while an unsmoothed candlestick uses the first price from its time range as its open price. (optional)</param>
        /// <param name="includeFirst">A flag that controls whether the candlestick that is covered by the from time should be included in the results. This flag enables clients to use the timestamp of the last completed candlestick received to poll for future candlesticks but avoid receiving the previous candlestick repeatedly. (optional)</param>
        /// <param name="dailyAlignment">The hour of the day (in the specified timezone) to use for granularities that have daily alignments. (optional)</param>
        /// <param name="alignmentTimezone">The timezone to use for the dailyAlignment parameter. Candlesticks with daily alignment will be aligned to the dailyAlignment hour within the alignmentTimezone.  Note that the returned times will still be represented in UTC. (optional)</param>
        /// <param name="weeklyAlignment">The day of the week used for granularities that have weekly alignment. (optional)</param>
        /// <returns>Task of ApiResponse (CandlesResponse)</returns>
        public async System.Threading.Tasks.Task<GeriRemenyi.Oanda.V20.Client.Client.ApiResponse<CandlesResponse>> GetInstrumentCandlesAsyncWithHttpInfo (InstrumentName instrument, DateTimeFormat? acceptDatetimeFormat = default(DateTimeFormat?), string price = default(string), CandlestickGranularity? granularity = default(CandlestickGranularity?), int? count = default(int?), string from = default(string), string to = default(string), bool? smooth = default(bool?), bool? includeFirst = default(bool?), int? dailyAlignment = default(int?), string alignmentTimezone = default(string), string weeklyAlignment = default(string))
        {

            GeriRemenyi.Oanda.V20.Client.Client.RequestOptions localVarRequestOptions = new GeriRemenyi.Oanda.V20.Client.Client.RequestOptions();

            String[] _contentTypes = new String[] {
            };

            // to determine the Accept header
            String[] _accepts = new String[] {
                "application/json"
            };
            
            foreach (var _contentType in _contentTypes)
                localVarRequestOptions.HeaderParameters.Add("Content-Type", _contentType);
            
            foreach (var _accept in _accepts)
                localVarRequestOptions.HeaderParameters.Add("Accept", _accept);
            
            localVarRequestOptions.PathParameters.Add("instrument", GeriRemenyi.Oanda.V20.Client.Client.ClientUtils.ParameterToString(instrument)); // path parameter
            if (price != null)
            {
                localVarRequestOptions.QueryParameters.Add(GeriRemenyi.Oanda.V20.Client.Client.ClientUtils.ParameterToMultiMap("", "price", price));
            }
            if (granularity != null)
            {
                localVarRequestOptions.QueryParameters.Add(GeriRemenyi.Oanda.V20.Client.Client.ClientUtils.ParameterToMultiMap("", "granularity", granularity));
            }
            if (count != null)
            {
                localVarRequestOptions.QueryParameters.Add(GeriRemenyi.Oanda.V20.Client.Client.ClientUtils.ParameterToMultiMap("", "count", count));
            }
            if (from != null)
            {
                localVarRequestOptions.QueryParameters.Add(GeriRemenyi.Oanda.V20.Client.Client.ClientUtils.ParameterToMultiMap("", "from", from));
            }
            if (to != null)
            {
                localVarRequestOptions.QueryParameters.Add(GeriRemenyi.Oanda.V20.Client.Client.ClientUtils.ParameterToMultiMap("", "to", to));
            }
            if (smooth != null)
            {
                localVarRequestOptions.QueryParameters.Add(GeriRemenyi.Oanda.V20.Client.Client.ClientUtils.ParameterToMultiMap("", "smooth", smooth));
            }
            if (includeFirst != null)
            {
                localVarRequestOptions.QueryParameters.Add(GeriRemenyi.Oanda.V20.Client.Client.ClientUtils.ParameterToMultiMap("", "includeFirst", includeFirst));
            }
            if (dailyAlignment != null)
            {
                localVarRequestOptions.QueryParameters.Add(GeriRemenyi.Oanda.V20.Client.Client.ClientUtils.ParameterToMultiMap("", "dailyAlignment", dailyAlignment));
            }
            if (alignmentTimezone != null)
            {
                localVarRequestOptions.QueryParameters.Add(GeriRemenyi.Oanda.V20.Client.Client.ClientUtils.ParameterToMultiMap("", "alignmentTimezone", alignmentTimezone));
            }
            if (weeklyAlignment != null)
            {
                localVarRequestOptions.QueryParameters.Add(GeriRemenyi.Oanda.V20.Client.Client.ClientUtils.ParameterToMultiMap("", "weeklyAlignment", weeklyAlignment));
            }
            if (acceptDatetimeFormat != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept-Datetime-Format", GeriRemenyi.Oanda.V20.Client.Client.ClientUtils.ParameterToString(acceptDatetimeFormat)); // header parameter
            }

            // authentication (PersonalAccessToken) required
            // bearer authentication required
            if (!String.IsNullOrEmpty(this.Configuration.AccessToken))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", "Bearer " + this.Configuration.AccessToken);
            }

            // make the HTTP request

            var localVarResponse = await this.AsynchronousClient.GetAsync<CandlesResponse>("/instruments/{instrument}/candles", localVarRequestOptions, this.Configuration);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("GetInstrumentCandles", localVarResponse);
                if (_exception != null) throw _exception;
            }

            return localVarResponse;
        }

        /// <summary>
        /// Get Order Book Fetch an order book for an instrument.
        /// </summary>
        /// <exception cref="GeriRemenyi.Oanda.V20.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="instrument">Instrument name</param>
        /// <param name="acceptDatetimeFormat">Format of DateTime fields in the request and response. (optional)</param>
        /// <param name="time">The time of the snapshot to fetch. If not specified, then the most recent snapshot is fetched. (optional)</param>
        /// <returns>InstrumentOrderBookResponse</returns>
        public InstrumentOrderBookResponse GetInstrumentOrderBook (InstrumentName instrument, DateTimeFormat? acceptDatetimeFormat = default(DateTimeFormat?), string time = default(string))
        {
             GeriRemenyi.Oanda.V20.Client.Client.ApiResponse<InstrumentOrderBookResponse> localVarResponse = GetInstrumentOrderBookWithHttpInfo(instrument, acceptDatetimeFormat, time);
             return localVarResponse.Data;
        }

        /// <summary>
        /// Get Order Book Fetch an order book for an instrument.
        /// </summary>
        /// <exception cref="GeriRemenyi.Oanda.V20.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="instrument">Instrument name</param>
        /// <param name="acceptDatetimeFormat">Format of DateTime fields in the request and response. (optional)</param>
        /// <param name="time">The time of the snapshot to fetch. If not specified, then the most recent snapshot is fetched. (optional)</param>
        /// <returns>ApiResponse of InstrumentOrderBookResponse</returns>
        public GeriRemenyi.Oanda.V20.Client.Client.ApiResponse< InstrumentOrderBookResponse > GetInstrumentOrderBookWithHttpInfo (InstrumentName instrument, DateTimeFormat? acceptDatetimeFormat = default(DateTimeFormat?), string time = default(string))
        {
            GeriRemenyi.Oanda.V20.Client.Client.RequestOptions localVarRequestOptions = new GeriRemenyi.Oanda.V20.Client.Client.RequestOptions();

            String[] _contentTypes = new String[] {
            };

            // to determine the Accept header
            String[] _accepts = new String[] {
                "application/json"
            };

            var localVarContentType = GeriRemenyi.Oanda.V20.Client.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = GeriRemenyi.Oanda.V20.Client.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            localVarRequestOptions.PathParameters.Add("instrument", GeriRemenyi.Oanda.V20.Client.Client.ClientUtils.ParameterToString(instrument)); // path parameter
            if (time != null)
            {
                localVarRequestOptions.QueryParameters.Add(GeriRemenyi.Oanda.V20.Client.Client.ClientUtils.ParameterToMultiMap("", "time", time));
            }
            if (acceptDatetimeFormat != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept-Datetime-Format", GeriRemenyi.Oanda.V20.Client.Client.ClientUtils.ParameterToString(acceptDatetimeFormat)); // header parameter
            }

            // authentication (PersonalAccessToken) required
            // bearer authentication required
            if (!String.IsNullOrEmpty(this.Configuration.AccessToken))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", "Bearer " + this.Configuration.AccessToken);
            }

            // make the HTTP request
            var localVarResponse = this.Client.Get< InstrumentOrderBookResponse >("/instruments/{instrument}/orderBook", localVarRequestOptions, this.Configuration);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("GetInstrumentOrderBook", localVarResponse);
                if (_exception != null) throw _exception;
            }

            return localVarResponse;
        }

        /// <summary>
        /// Get Order Book Fetch an order book for an instrument.
        /// </summary>
        /// <exception cref="GeriRemenyi.Oanda.V20.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="instrument">Instrument name</param>
        /// <param name="acceptDatetimeFormat">Format of DateTime fields in the request and response. (optional)</param>
        /// <param name="time">The time of the snapshot to fetch. If not specified, then the most recent snapshot is fetched. (optional)</param>
        /// <returns>Task of InstrumentOrderBookResponse</returns>
        public async System.Threading.Tasks.Task<InstrumentOrderBookResponse> GetInstrumentOrderBookAsync (InstrumentName instrument, DateTimeFormat? acceptDatetimeFormat = default(DateTimeFormat?), string time = default(string))
        {
             GeriRemenyi.Oanda.V20.Client.Client.ApiResponse<InstrumentOrderBookResponse> localVarResponse = await GetInstrumentOrderBookAsyncWithHttpInfo(instrument, acceptDatetimeFormat, time);
             return localVarResponse.Data;

        }

        /// <summary>
        /// Get Order Book Fetch an order book for an instrument.
        /// </summary>
        /// <exception cref="GeriRemenyi.Oanda.V20.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="instrument">Instrument name</param>
        /// <param name="acceptDatetimeFormat">Format of DateTime fields in the request and response. (optional)</param>
        /// <param name="time">The time of the snapshot to fetch. If not specified, then the most recent snapshot is fetched. (optional)</param>
        /// <returns>Task of ApiResponse (InstrumentOrderBookResponse)</returns>
        public async System.Threading.Tasks.Task<GeriRemenyi.Oanda.V20.Client.Client.ApiResponse<InstrumentOrderBookResponse>> GetInstrumentOrderBookAsyncWithHttpInfo (InstrumentName instrument, DateTimeFormat? acceptDatetimeFormat = default(DateTimeFormat?), string time = default(string))
        {

            GeriRemenyi.Oanda.V20.Client.Client.RequestOptions localVarRequestOptions = new GeriRemenyi.Oanda.V20.Client.Client.RequestOptions();

            String[] _contentTypes = new String[] {
            };

            // to determine the Accept header
            String[] _accepts = new String[] {
                "application/json"
            };
            
            foreach (var _contentType in _contentTypes)
                localVarRequestOptions.HeaderParameters.Add("Content-Type", _contentType);
            
            foreach (var _accept in _accepts)
                localVarRequestOptions.HeaderParameters.Add("Accept", _accept);
            
            localVarRequestOptions.PathParameters.Add("instrument", GeriRemenyi.Oanda.V20.Client.Client.ClientUtils.ParameterToString(instrument)); // path parameter
            if (time != null)
            {
                localVarRequestOptions.QueryParameters.Add(GeriRemenyi.Oanda.V20.Client.Client.ClientUtils.ParameterToMultiMap("", "time", time));
            }
            if (acceptDatetimeFormat != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept-Datetime-Format", GeriRemenyi.Oanda.V20.Client.Client.ClientUtils.ParameterToString(acceptDatetimeFormat)); // header parameter
            }

            // authentication (PersonalAccessToken) required
            // bearer authentication required
            if (!String.IsNullOrEmpty(this.Configuration.AccessToken))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", "Bearer " + this.Configuration.AccessToken);
            }

            // make the HTTP request

            var localVarResponse = await this.AsynchronousClient.GetAsync<InstrumentOrderBookResponse>("/instruments/{instrument}/orderBook", localVarRequestOptions, this.Configuration);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("GetInstrumentOrderBook", localVarResponse);
                if (_exception != null) throw _exception;
            }

            return localVarResponse;
        }

        /// <summary>
        /// Get Position Book Fetch a position book for an instrument.
        /// </summary>
        /// <exception cref="GeriRemenyi.Oanda.V20.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="instrument">Instrument name</param>
        /// <param name="acceptDatetimeFormat">Format of DateTime fields in the request and response. (optional)</param>
        /// <param name="time">The time of the snapshot to fetch. If not specified, then the most recent snapshot is fetched. (optional)</param>
        /// <returns>InstrumentPositionBookResponse</returns>
        public InstrumentPositionBookResponse GetInstrumentPositionBook (InstrumentName instrument, DateTimeFormat? acceptDatetimeFormat = default(DateTimeFormat?), string time = default(string))
        {
             GeriRemenyi.Oanda.V20.Client.Client.ApiResponse<InstrumentPositionBookResponse> localVarResponse = GetInstrumentPositionBookWithHttpInfo(instrument, acceptDatetimeFormat, time);
             return localVarResponse.Data;
        }

        /// <summary>
        /// Get Position Book Fetch a position book for an instrument.
        /// </summary>
        /// <exception cref="GeriRemenyi.Oanda.V20.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="instrument">Instrument name</param>
        /// <param name="acceptDatetimeFormat">Format of DateTime fields in the request and response. (optional)</param>
        /// <param name="time">The time of the snapshot to fetch. If not specified, then the most recent snapshot is fetched. (optional)</param>
        /// <returns>ApiResponse of InstrumentPositionBookResponse</returns>
        public GeriRemenyi.Oanda.V20.Client.Client.ApiResponse< InstrumentPositionBookResponse > GetInstrumentPositionBookWithHttpInfo (InstrumentName instrument, DateTimeFormat? acceptDatetimeFormat = default(DateTimeFormat?), string time = default(string))
        {
            GeriRemenyi.Oanda.V20.Client.Client.RequestOptions localVarRequestOptions = new GeriRemenyi.Oanda.V20.Client.Client.RequestOptions();

            String[] _contentTypes = new String[] {
            };

            // to determine the Accept header
            String[] _accepts = new String[] {
                "application/json"
            };

            var localVarContentType = GeriRemenyi.Oanda.V20.Client.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = GeriRemenyi.Oanda.V20.Client.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            localVarRequestOptions.PathParameters.Add("instrument", GeriRemenyi.Oanda.V20.Client.Client.ClientUtils.ParameterToString(instrument)); // path parameter
            if (time != null)
            {
                localVarRequestOptions.QueryParameters.Add(GeriRemenyi.Oanda.V20.Client.Client.ClientUtils.ParameterToMultiMap("", "time", time));
            }
            if (acceptDatetimeFormat != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept-Datetime-Format", GeriRemenyi.Oanda.V20.Client.Client.ClientUtils.ParameterToString(acceptDatetimeFormat)); // header parameter
            }

            // authentication (PersonalAccessToken) required
            // bearer authentication required
            if (!String.IsNullOrEmpty(this.Configuration.AccessToken))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", "Bearer " + this.Configuration.AccessToken);
            }

            // make the HTTP request
            var localVarResponse = this.Client.Get< InstrumentPositionBookResponse >("/instruments/{instrument}/positionBook", localVarRequestOptions, this.Configuration);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("GetInstrumentPositionBook", localVarResponse);
                if (_exception != null) throw _exception;
            }

            return localVarResponse;
        }

        /// <summary>
        /// Get Position Book Fetch a position book for an instrument.
        /// </summary>
        /// <exception cref="GeriRemenyi.Oanda.V20.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="instrument">Instrument name</param>
        /// <param name="acceptDatetimeFormat">Format of DateTime fields in the request and response. (optional)</param>
        /// <param name="time">The time of the snapshot to fetch. If not specified, then the most recent snapshot is fetched. (optional)</param>
        /// <returns>Task of InstrumentPositionBookResponse</returns>
        public async System.Threading.Tasks.Task<InstrumentPositionBookResponse> GetInstrumentPositionBookAsync (InstrumentName instrument, DateTimeFormat? acceptDatetimeFormat = default(DateTimeFormat?), string time = default(string))
        {
             GeriRemenyi.Oanda.V20.Client.Client.ApiResponse<InstrumentPositionBookResponse> localVarResponse = await GetInstrumentPositionBookAsyncWithHttpInfo(instrument, acceptDatetimeFormat, time);
             return localVarResponse.Data;

        }

        /// <summary>
        /// Get Position Book Fetch a position book for an instrument.
        /// </summary>
        /// <exception cref="GeriRemenyi.Oanda.V20.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="instrument">Instrument name</param>
        /// <param name="acceptDatetimeFormat">Format of DateTime fields in the request and response. (optional)</param>
        /// <param name="time">The time of the snapshot to fetch. If not specified, then the most recent snapshot is fetched. (optional)</param>
        /// <returns>Task of ApiResponse (InstrumentPositionBookResponse)</returns>
        public async System.Threading.Tasks.Task<GeriRemenyi.Oanda.V20.Client.Client.ApiResponse<InstrumentPositionBookResponse>> GetInstrumentPositionBookAsyncWithHttpInfo (InstrumentName instrument, DateTimeFormat? acceptDatetimeFormat = default(DateTimeFormat?), string time = default(string))
        {

            GeriRemenyi.Oanda.V20.Client.Client.RequestOptions localVarRequestOptions = new GeriRemenyi.Oanda.V20.Client.Client.RequestOptions();

            String[] _contentTypes = new String[] {
            };

            // to determine the Accept header
            String[] _accepts = new String[] {
                "application/json"
            };
            
            foreach (var _contentType in _contentTypes)
                localVarRequestOptions.HeaderParameters.Add("Content-Type", _contentType);
            
            foreach (var _accept in _accepts)
                localVarRequestOptions.HeaderParameters.Add("Accept", _accept);
            
            localVarRequestOptions.PathParameters.Add("instrument", GeriRemenyi.Oanda.V20.Client.Client.ClientUtils.ParameterToString(instrument)); // path parameter
            if (time != null)
            {
                localVarRequestOptions.QueryParameters.Add(GeriRemenyi.Oanda.V20.Client.Client.ClientUtils.ParameterToMultiMap("", "time", time));
            }
            if (acceptDatetimeFormat != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept-Datetime-Format", GeriRemenyi.Oanda.V20.Client.Client.ClientUtils.ParameterToString(acceptDatetimeFormat)); // header parameter
            }

            // authentication (PersonalAccessToken) required
            // bearer authentication required
            if (!String.IsNullOrEmpty(this.Configuration.AccessToken))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", "Bearer " + this.Configuration.AccessToken);
            }

            // make the HTTP request

            var localVarResponse = await this.AsynchronousClient.GetAsync<InstrumentPositionBookResponse>("/instruments/{instrument}/positionBook", localVarRequestOptions, this.Configuration);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("GetInstrumentPositionBook", localVarResponse);
                if (_exception != null) throw _exception;
            }

            return localVarResponse;
        }

    }
}
