/* 
 * OANDA v20 API
 *
 * The full OANDA v20 API Specification. This specification defines how to interact with v20 Accounts, Trades, Orders, Pricing and more.
 *
 * The version of the OpenAPI document: 3.0.25
 * Contact: api@oanda.com
 * Generated by: https://github.com/openapitools/openapi-generator.git
 */


using System;
using System.Collections.Generic;
using System.Collections.ObjectModel;
using System.Linq;
using System.Net;
using System.Net.Mime;
using GeriRemenyi.Oanda.V20.Client;
using GeriRemenyi.Oanda.V20.Model;

namespace GeriRemenyi.Oanda.V20.Api
{

    /// <summary>
    /// Represents a collection of functions to interact with the API endpoints
    /// </summary>
    public interface IInstrumentApiSync : IApiAccessor
    {
        #region Synchronous Operations
        /// <summary>
        /// Get Candlesticks
        /// </summary>
        /// <remarks>
        /// Fetch candlestick data for an instrument.
        /// </remarks>
        /// <exception cref="GeriRemenyi.Oanda.V20.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="instrument">Instrument name</param>
        /// <param name="acceptDatetimeFormat">Format of DateTime fields in the request and response. (optional)</param>
        /// <param name="price">The Price component(s) to get candlestick data for. Can contain any combination of the characters \&quot;M\&quot; (midpoint candles) \&quot;B\&quot; (bid candles) and \&quot;A\&quot; (ask candles). (optional)</param>
        /// <param name="granularity">The granularity of the candlesticks to fetch (optional)</param>
        /// <param name="count">The number of candlesticks to return in the reponse. Count should not be specified if both the start and end parameters are provided, as the time range combined with the graularity will determine the number of candlesticks to return. (optional)</param>
        /// <param name="from">The start of the time range to fetch candlesticks for. (optional)</param>
        /// <param name="to">The end of the time range to fetch candlesticks for. (optional)</param>
        /// <param name="smooth">A flag that controls whether the candlestick is \&quot;smoothed\&quot; or not.  A smoothed candlestick uses the previous candle&#39;s close price as its open price, while an unsmoothed candlestick uses the first price from its time range as its open price. (optional)</param>
        /// <param name="includeFirst">A flag that controls whether the candlestick that is covered by the from time should be included in the results. This flag enables clients to use the timestamp of the last completed candlestick received to poll for future candlesticks but avoid receiving the previous candlestick repeatedly. (optional)</param>
        /// <param name="dailyAlignment">The hour of the day (in the specified timezone) to use for granularities that have daily alignments. (optional)</param>
        /// <param name="alignmentTimezone">The timezone to use for the dailyAlignment parameter. Candlesticks with daily alignment will be aligned to the dailyAlignment hour within the alignmentTimezone.  Note that the returned times will still be represented in UTC. (optional)</param>
        /// <param name="weeklyAlignment">The day of the week used for granularities that have weekly alignment. (optional)</param>
        /// <returns>InlineResponse2006</returns>
        InlineResponse2006 InstrumentsInstrumentCandlesGet (string instrument, string acceptDatetimeFormat = default(string), string price = default(string), string granularity = default(string), int? count = default(int?), string from = default(string), string to = default(string), bool? smooth = default(bool?), bool? includeFirst = default(bool?), int? dailyAlignment = default(int?), string alignmentTimezone = default(string), string weeklyAlignment = default(string));

        /// <summary>
        /// Get Candlesticks
        /// </summary>
        /// <remarks>
        /// Fetch candlestick data for an instrument.
        /// </remarks>
        /// <exception cref="GeriRemenyi.Oanda.V20.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="instrument">Instrument name</param>
        /// <param name="acceptDatetimeFormat">Format of DateTime fields in the request and response. (optional)</param>
        /// <param name="price">The Price component(s) to get candlestick data for. Can contain any combination of the characters \&quot;M\&quot; (midpoint candles) \&quot;B\&quot; (bid candles) and \&quot;A\&quot; (ask candles). (optional)</param>
        /// <param name="granularity">The granularity of the candlesticks to fetch (optional)</param>
        /// <param name="count">The number of candlesticks to return in the reponse. Count should not be specified if both the start and end parameters are provided, as the time range combined with the graularity will determine the number of candlesticks to return. (optional)</param>
        /// <param name="from">The start of the time range to fetch candlesticks for. (optional)</param>
        /// <param name="to">The end of the time range to fetch candlesticks for. (optional)</param>
        /// <param name="smooth">A flag that controls whether the candlestick is \&quot;smoothed\&quot; or not.  A smoothed candlestick uses the previous candle&#39;s close price as its open price, while an unsmoothed candlestick uses the first price from its time range as its open price. (optional)</param>
        /// <param name="includeFirst">A flag that controls whether the candlestick that is covered by the from time should be included in the results. This flag enables clients to use the timestamp of the last completed candlestick received to poll for future candlesticks but avoid receiving the previous candlestick repeatedly. (optional)</param>
        /// <param name="dailyAlignment">The hour of the day (in the specified timezone) to use for granularities that have daily alignments. (optional)</param>
        /// <param name="alignmentTimezone">The timezone to use for the dailyAlignment parameter. Candlesticks with daily alignment will be aligned to the dailyAlignment hour within the alignmentTimezone.  Note that the returned times will still be represented in UTC. (optional)</param>
        /// <param name="weeklyAlignment">The day of the week used for granularities that have weekly alignment. (optional)</param>
        /// <returns>ApiResponse of InlineResponse2006</returns>
        ApiResponse<InlineResponse2006> InstrumentsInstrumentCandlesGetWithHttpInfo (string instrument, string acceptDatetimeFormat = default(string), string price = default(string), string granularity = default(string), int? count = default(int?), string from = default(string), string to = default(string), bool? smooth = default(bool?), bool? includeFirst = default(bool?), int? dailyAlignment = default(int?), string alignmentTimezone = default(string), string weeklyAlignment = default(string));
        /// <summary>
        /// Get Order Book
        /// </summary>
        /// <remarks>
        /// Fetch an order book for an instrument.
        /// </remarks>
        /// <exception cref="GeriRemenyi.Oanda.V20.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="instrument">Instrument name</param>
        /// <param name="acceptDatetimeFormat">Format of DateTime fields in the request and response. (optional)</param>
        /// <param name="time">The time of the snapshot to fetch. If not specified, then the most recent snapshot is fetched. (optional)</param>
        /// <returns>InlineResponse2007</returns>
        InlineResponse2007 InstrumentsInstrumentOrderBookGet (string instrument, string acceptDatetimeFormat = default(string), string time = default(string));

        /// <summary>
        /// Get Order Book
        /// </summary>
        /// <remarks>
        /// Fetch an order book for an instrument.
        /// </remarks>
        /// <exception cref="GeriRemenyi.Oanda.V20.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="instrument">Instrument name</param>
        /// <param name="acceptDatetimeFormat">Format of DateTime fields in the request and response. (optional)</param>
        /// <param name="time">The time of the snapshot to fetch. If not specified, then the most recent snapshot is fetched. (optional)</param>
        /// <returns>ApiResponse of InlineResponse2007</returns>
        ApiResponse<InlineResponse2007> InstrumentsInstrumentOrderBookGetWithHttpInfo (string instrument, string acceptDatetimeFormat = default(string), string time = default(string));
        /// <summary>
        /// Get Position Book
        /// </summary>
        /// <remarks>
        /// Fetch a position book for an instrument.
        /// </remarks>
        /// <exception cref="GeriRemenyi.Oanda.V20.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="instrument">Instrument name</param>
        /// <param name="acceptDatetimeFormat">Format of DateTime fields in the request and response. (optional)</param>
        /// <param name="time">The time of the snapshot to fetch. If not specified, then the most recent snapshot is fetched. (optional)</param>
        /// <returns>InlineResponse2008</returns>
        InlineResponse2008 InstrumentsInstrumentPositionBookGet (string instrument, string acceptDatetimeFormat = default(string), string time = default(string));

        /// <summary>
        /// Get Position Book
        /// </summary>
        /// <remarks>
        /// Fetch a position book for an instrument.
        /// </remarks>
        /// <exception cref="GeriRemenyi.Oanda.V20.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="instrument">Instrument name</param>
        /// <param name="acceptDatetimeFormat">Format of DateTime fields in the request and response. (optional)</param>
        /// <param name="time">The time of the snapshot to fetch. If not specified, then the most recent snapshot is fetched. (optional)</param>
        /// <returns>ApiResponse of InlineResponse2008</returns>
        ApiResponse<InlineResponse2008> InstrumentsInstrumentPositionBookGetWithHttpInfo (string instrument, string acceptDatetimeFormat = default(string), string time = default(string));
        #endregion Synchronous Operations
    }

    /// <summary>
    /// Represents a collection of functions to interact with the API endpoints
    /// </summary>
    public interface IInstrumentApiAsync : IApiAccessor
    {
        #region Asynchronous Operations
        /// <summary>
        /// Get Candlesticks
        /// </summary>
        /// <remarks>
        /// Fetch candlestick data for an instrument.
        /// </remarks>
        /// <exception cref="GeriRemenyi.Oanda.V20.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="instrument">Instrument name</param>
        /// <param name="acceptDatetimeFormat">Format of DateTime fields in the request and response. (optional)</param>
        /// <param name="price">The Price component(s) to get candlestick data for. Can contain any combination of the characters \&quot;M\&quot; (midpoint candles) \&quot;B\&quot; (bid candles) and \&quot;A\&quot; (ask candles). (optional)</param>
        /// <param name="granularity">The granularity of the candlesticks to fetch (optional)</param>
        /// <param name="count">The number of candlesticks to return in the reponse. Count should not be specified if both the start and end parameters are provided, as the time range combined with the graularity will determine the number of candlesticks to return. (optional)</param>
        /// <param name="from">The start of the time range to fetch candlesticks for. (optional)</param>
        /// <param name="to">The end of the time range to fetch candlesticks for. (optional)</param>
        /// <param name="smooth">A flag that controls whether the candlestick is \&quot;smoothed\&quot; or not.  A smoothed candlestick uses the previous candle&#39;s close price as its open price, while an unsmoothed candlestick uses the first price from its time range as its open price. (optional)</param>
        /// <param name="includeFirst">A flag that controls whether the candlestick that is covered by the from time should be included in the results. This flag enables clients to use the timestamp of the last completed candlestick received to poll for future candlesticks but avoid receiving the previous candlestick repeatedly. (optional)</param>
        /// <param name="dailyAlignment">The hour of the day (in the specified timezone) to use for granularities that have daily alignments. (optional)</param>
        /// <param name="alignmentTimezone">The timezone to use for the dailyAlignment parameter. Candlesticks with daily alignment will be aligned to the dailyAlignment hour within the alignmentTimezone.  Note that the returned times will still be represented in UTC. (optional)</param>
        /// <param name="weeklyAlignment">The day of the week used for granularities that have weekly alignment. (optional)</param>
        /// <returns>Task of InlineResponse2006</returns>
        System.Threading.Tasks.Task<InlineResponse2006> InstrumentsInstrumentCandlesGetAsync (string instrument, string acceptDatetimeFormat = default(string), string price = default(string), string granularity = default(string), int? count = default(int?), string from = default(string), string to = default(string), bool? smooth = default(bool?), bool? includeFirst = default(bool?), int? dailyAlignment = default(int?), string alignmentTimezone = default(string), string weeklyAlignment = default(string));

        /// <summary>
        /// Get Candlesticks
        /// </summary>
        /// <remarks>
        /// Fetch candlestick data for an instrument.
        /// </remarks>
        /// <exception cref="GeriRemenyi.Oanda.V20.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="instrument">Instrument name</param>
        /// <param name="acceptDatetimeFormat">Format of DateTime fields in the request and response. (optional)</param>
        /// <param name="price">The Price component(s) to get candlestick data for. Can contain any combination of the characters \&quot;M\&quot; (midpoint candles) \&quot;B\&quot; (bid candles) and \&quot;A\&quot; (ask candles). (optional)</param>
        /// <param name="granularity">The granularity of the candlesticks to fetch (optional)</param>
        /// <param name="count">The number of candlesticks to return in the reponse. Count should not be specified if both the start and end parameters are provided, as the time range combined with the graularity will determine the number of candlesticks to return. (optional)</param>
        /// <param name="from">The start of the time range to fetch candlesticks for. (optional)</param>
        /// <param name="to">The end of the time range to fetch candlesticks for. (optional)</param>
        /// <param name="smooth">A flag that controls whether the candlestick is \&quot;smoothed\&quot; or not.  A smoothed candlestick uses the previous candle&#39;s close price as its open price, while an unsmoothed candlestick uses the first price from its time range as its open price. (optional)</param>
        /// <param name="includeFirst">A flag that controls whether the candlestick that is covered by the from time should be included in the results. This flag enables clients to use the timestamp of the last completed candlestick received to poll for future candlesticks but avoid receiving the previous candlestick repeatedly. (optional)</param>
        /// <param name="dailyAlignment">The hour of the day (in the specified timezone) to use for granularities that have daily alignments. (optional)</param>
        /// <param name="alignmentTimezone">The timezone to use for the dailyAlignment parameter. Candlesticks with daily alignment will be aligned to the dailyAlignment hour within the alignmentTimezone.  Note that the returned times will still be represented in UTC. (optional)</param>
        /// <param name="weeklyAlignment">The day of the week used for granularities that have weekly alignment. (optional)</param>
        /// <returns>Task of ApiResponse (InlineResponse2006)</returns>
        System.Threading.Tasks.Task<ApiResponse<InlineResponse2006>> InstrumentsInstrumentCandlesGetAsyncWithHttpInfo (string instrument, string acceptDatetimeFormat = default(string), string price = default(string), string granularity = default(string), int? count = default(int?), string from = default(string), string to = default(string), bool? smooth = default(bool?), bool? includeFirst = default(bool?), int? dailyAlignment = default(int?), string alignmentTimezone = default(string), string weeklyAlignment = default(string));
        /// <summary>
        /// Get Order Book
        /// </summary>
        /// <remarks>
        /// Fetch an order book for an instrument.
        /// </remarks>
        /// <exception cref="GeriRemenyi.Oanda.V20.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="instrument">Instrument name</param>
        /// <param name="acceptDatetimeFormat">Format of DateTime fields in the request and response. (optional)</param>
        /// <param name="time">The time of the snapshot to fetch. If not specified, then the most recent snapshot is fetched. (optional)</param>
        /// <returns>Task of InlineResponse2007</returns>
        System.Threading.Tasks.Task<InlineResponse2007> InstrumentsInstrumentOrderBookGetAsync (string instrument, string acceptDatetimeFormat = default(string), string time = default(string));

        /// <summary>
        /// Get Order Book
        /// </summary>
        /// <remarks>
        /// Fetch an order book for an instrument.
        /// </remarks>
        /// <exception cref="GeriRemenyi.Oanda.V20.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="instrument">Instrument name</param>
        /// <param name="acceptDatetimeFormat">Format of DateTime fields in the request and response. (optional)</param>
        /// <param name="time">The time of the snapshot to fetch. If not specified, then the most recent snapshot is fetched. (optional)</param>
        /// <returns>Task of ApiResponse (InlineResponse2007)</returns>
        System.Threading.Tasks.Task<ApiResponse<InlineResponse2007>> InstrumentsInstrumentOrderBookGetAsyncWithHttpInfo (string instrument, string acceptDatetimeFormat = default(string), string time = default(string));
        /// <summary>
        /// Get Position Book
        /// </summary>
        /// <remarks>
        /// Fetch a position book for an instrument.
        /// </remarks>
        /// <exception cref="GeriRemenyi.Oanda.V20.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="instrument">Instrument name</param>
        /// <param name="acceptDatetimeFormat">Format of DateTime fields in the request and response. (optional)</param>
        /// <param name="time">The time of the snapshot to fetch. If not specified, then the most recent snapshot is fetched. (optional)</param>
        /// <returns>Task of InlineResponse2008</returns>
        System.Threading.Tasks.Task<InlineResponse2008> InstrumentsInstrumentPositionBookGetAsync (string instrument, string acceptDatetimeFormat = default(string), string time = default(string));

        /// <summary>
        /// Get Position Book
        /// </summary>
        /// <remarks>
        /// Fetch a position book for an instrument.
        /// </remarks>
        /// <exception cref="GeriRemenyi.Oanda.V20.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="instrument">Instrument name</param>
        /// <param name="acceptDatetimeFormat">Format of DateTime fields in the request and response. (optional)</param>
        /// <param name="time">The time of the snapshot to fetch. If not specified, then the most recent snapshot is fetched. (optional)</param>
        /// <returns>Task of ApiResponse (InlineResponse2008)</returns>
        System.Threading.Tasks.Task<ApiResponse<InlineResponse2008>> InstrumentsInstrumentPositionBookGetAsyncWithHttpInfo (string instrument, string acceptDatetimeFormat = default(string), string time = default(string));
        #endregion Asynchronous Operations
    }

    /// <summary>
    /// Represents a collection of functions to interact with the API endpoints
    /// </summary>
    public interface IInstrumentApi : IInstrumentApiSync, IInstrumentApiAsync
    {

    }

    /// <summary>
    /// Represents a collection of functions to interact with the API endpoints
    /// </summary>
    public partial class InstrumentApi : IInstrumentApi
    {
        private GeriRemenyi.Oanda.V20.Client.ExceptionFactory _exceptionFactory = (name, response) => null;

        /// <summary>
        /// Initializes a new instance of the <see cref="InstrumentApi"/> class.
        /// </summary>
        /// <returns></returns>
        public InstrumentApi() : this((string) null)
        {
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="InstrumentApi"/> class.
        /// </summary>
        /// <returns></returns>
        public InstrumentApi(String basePath)
        {
            this.Configuration = GeriRemenyi.Oanda.V20.Client.Configuration.MergeConfigurations(
                GeriRemenyi.Oanda.V20.Client.GlobalConfiguration.Instance,
                new GeriRemenyi.Oanda.V20.Client.Configuration { BasePath = basePath }
            );
            this.Client = new GeriRemenyi.Oanda.V20.Client.ApiClient(this.Configuration.BasePath);
            this.AsynchronousClient = new GeriRemenyi.Oanda.V20.Client.ApiClient(this.Configuration.BasePath);
            this.ExceptionFactory = GeriRemenyi.Oanda.V20.Client.Configuration.DefaultExceptionFactory;
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="InstrumentApi"/> class
        /// using Configuration object
        /// </summary>
        /// <param name="configuration">An instance of Configuration</param>
        /// <returns></returns>
        public InstrumentApi(GeriRemenyi.Oanda.V20.Client.Configuration configuration)
        {
            if (configuration == null) throw new ArgumentNullException("configuration");

            this.Configuration = GeriRemenyi.Oanda.V20.Client.Configuration.MergeConfigurations(
                GeriRemenyi.Oanda.V20.Client.GlobalConfiguration.Instance,
                configuration
            );
            this.Client = new GeriRemenyi.Oanda.V20.Client.ApiClient(this.Configuration.BasePath);
            this.AsynchronousClient = new GeriRemenyi.Oanda.V20.Client.ApiClient(this.Configuration.BasePath);
            ExceptionFactory = GeriRemenyi.Oanda.V20.Client.Configuration.DefaultExceptionFactory;
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="InstrumentApi"/> class
        /// using a Configuration object and client instance.
        /// </summary>
        /// <param name="client">The client interface for synchronous API access.</param>
        /// <param name="asyncClient">The client interface for asynchronous API access.</param>
        /// <param name="configuration">The configuration object.</param>
        public InstrumentApi(GeriRemenyi.Oanda.V20.Client.ISynchronousClient client,GeriRemenyi.Oanda.V20.Client.IAsynchronousClient asyncClient, GeriRemenyi.Oanda.V20.Client.IReadableConfiguration configuration)
        {
            if(client == null) throw new ArgumentNullException("client");
            if(asyncClient == null) throw new ArgumentNullException("asyncClient");
            if(configuration == null) throw new ArgumentNullException("configuration");

            this.Client = client;
            this.AsynchronousClient = asyncClient;
            this.Configuration = configuration;
            this.ExceptionFactory = GeriRemenyi.Oanda.V20.Client.Configuration.DefaultExceptionFactory;
        }

        /// <summary>
        /// The client for accessing this underlying API asynchronously.
        /// </summary>
        public GeriRemenyi.Oanda.V20.Client.IAsynchronousClient AsynchronousClient { get; set; }

        /// <summary>
        /// The client for accessing this underlying API synchronously.
        /// </summary>
        public GeriRemenyi.Oanda.V20.Client.ISynchronousClient Client { get; set; }

        /// <summary>
        /// Gets the base path of the API client.
        /// </summary>
        /// <value>The base path</value>
        public String GetBasePath()
        {
            return this.Configuration.BasePath;
        }

        /// <summary>
        /// Gets or sets the configuration object
        /// </summary>
        /// <value>An instance of the Configuration</value>
        public GeriRemenyi.Oanda.V20.Client.IReadableConfiguration Configuration {get; set;}

        /// <summary>
        /// Provides a factory method hook for the creation of exceptions.
        /// </summary>
        public GeriRemenyi.Oanda.V20.Client.ExceptionFactory ExceptionFactory
        {
            get
            {
                if (_exceptionFactory != null && _exceptionFactory.GetInvocationList().Length > 1)
                {
                    throw new InvalidOperationException("Multicast delegate for ExceptionFactory is unsupported.");
                }
                return _exceptionFactory;
            }
            set { _exceptionFactory = value; }
        }

        /// <summary>
        /// Get Candlesticks Fetch candlestick data for an instrument.
        /// </summary>
        /// <exception cref="GeriRemenyi.Oanda.V20.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="instrument">Instrument name</param>
        /// <param name="acceptDatetimeFormat">Format of DateTime fields in the request and response. (optional)</param>
        /// <param name="price">The Price component(s) to get candlestick data for. Can contain any combination of the characters \&quot;M\&quot; (midpoint candles) \&quot;B\&quot; (bid candles) and \&quot;A\&quot; (ask candles). (optional)</param>
        /// <param name="granularity">The granularity of the candlesticks to fetch (optional)</param>
        /// <param name="count">The number of candlesticks to return in the reponse. Count should not be specified if both the start and end parameters are provided, as the time range combined with the graularity will determine the number of candlesticks to return. (optional)</param>
        /// <param name="from">The start of the time range to fetch candlesticks for. (optional)</param>
        /// <param name="to">The end of the time range to fetch candlesticks for. (optional)</param>
        /// <param name="smooth">A flag that controls whether the candlestick is \&quot;smoothed\&quot; or not.  A smoothed candlestick uses the previous candle&#39;s close price as its open price, while an unsmoothed candlestick uses the first price from its time range as its open price. (optional)</param>
        /// <param name="includeFirst">A flag that controls whether the candlestick that is covered by the from time should be included in the results. This flag enables clients to use the timestamp of the last completed candlestick received to poll for future candlesticks but avoid receiving the previous candlestick repeatedly. (optional)</param>
        /// <param name="dailyAlignment">The hour of the day (in the specified timezone) to use for granularities that have daily alignments. (optional)</param>
        /// <param name="alignmentTimezone">The timezone to use for the dailyAlignment parameter. Candlesticks with daily alignment will be aligned to the dailyAlignment hour within the alignmentTimezone.  Note that the returned times will still be represented in UTC. (optional)</param>
        /// <param name="weeklyAlignment">The day of the week used for granularities that have weekly alignment. (optional)</param>
        /// <returns>InlineResponse2006</returns>
        public InlineResponse2006 InstrumentsInstrumentCandlesGet (string instrument, string acceptDatetimeFormat = default(string), string price = default(string), string granularity = default(string), int? count = default(int?), string from = default(string), string to = default(string), bool? smooth = default(bool?), bool? includeFirst = default(bool?), int? dailyAlignment = default(int?), string alignmentTimezone = default(string), string weeklyAlignment = default(string))
        {
             GeriRemenyi.Oanda.V20.Client.ApiResponse<InlineResponse2006> localVarResponse = InstrumentsInstrumentCandlesGetWithHttpInfo(instrument, acceptDatetimeFormat, price, granularity, count, from, to, smooth, includeFirst, dailyAlignment, alignmentTimezone, weeklyAlignment);
             return localVarResponse.Data;
        }

        /// <summary>
        /// Get Candlesticks Fetch candlestick data for an instrument.
        /// </summary>
        /// <exception cref="GeriRemenyi.Oanda.V20.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="instrument">Instrument name</param>
        /// <param name="acceptDatetimeFormat">Format of DateTime fields in the request and response. (optional)</param>
        /// <param name="price">The Price component(s) to get candlestick data for. Can contain any combination of the characters \&quot;M\&quot; (midpoint candles) \&quot;B\&quot; (bid candles) and \&quot;A\&quot; (ask candles). (optional)</param>
        /// <param name="granularity">The granularity of the candlesticks to fetch (optional)</param>
        /// <param name="count">The number of candlesticks to return in the reponse. Count should not be specified if both the start and end parameters are provided, as the time range combined with the graularity will determine the number of candlesticks to return. (optional)</param>
        /// <param name="from">The start of the time range to fetch candlesticks for. (optional)</param>
        /// <param name="to">The end of the time range to fetch candlesticks for. (optional)</param>
        /// <param name="smooth">A flag that controls whether the candlestick is \&quot;smoothed\&quot; or not.  A smoothed candlestick uses the previous candle&#39;s close price as its open price, while an unsmoothed candlestick uses the first price from its time range as its open price. (optional)</param>
        /// <param name="includeFirst">A flag that controls whether the candlestick that is covered by the from time should be included in the results. This flag enables clients to use the timestamp of the last completed candlestick received to poll for future candlesticks but avoid receiving the previous candlestick repeatedly. (optional)</param>
        /// <param name="dailyAlignment">The hour of the day (in the specified timezone) to use for granularities that have daily alignments. (optional)</param>
        /// <param name="alignmentTimezone">The timezone to use for the dailyAlignment parameter. Candlesticks with daily alignment will be aligned to the dailyAlignment hour within the alignmentTimezone.  Note that the returned times will still be represented in UTC. (optional)</param>
        /// <param name="weeklyAlignment">The day of the week used for granularities that have weekly alignment. (optional)</param>
        /// <returns>ApiResponse of InlineResponse2006</returns>
        public GeriRemenyi.Oanda.V20.Client.ApiResponse< InlineResponse2006 > InstrumentsInstrumentCandlesGetWithHttpInfo (string instrument, string acceptDatetimeFormat = default(string), string price = default(string), string granularity = default(string), int? count = default(int?), string from = default(string), string to = default(string), bool? smooth = default(bool?), bool? includeFirst = default(bool?), int? dailyAlignment = default(int?), string alignmentTimezone = default(string), string weeklyAlignment = default(string))
        {
            // verify the required parameter 'instrument' is set
            if (instrument == null)
                throw new GeriRemenyi.Oanda.V20.Client.ApiException(400, "Missing required parameter 'instrument' when calling InstrumentApi->InstrumentsInstrumentCandlesGet");

            GeriRemenyi.Oanda.V20.Client.RequestOptions localVarRequestOptions = new GeriRemenyi.Oanda.V20.Client.RequestOptions();

            String[] _contentTypes = new String[] {
            };

            // to determine the Accept header
            String[] _accepts = new String[] {
                "application/json"
            };

            var localVarContentType = GeriRemenyi.Oanda.V20.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = GeriRemenyi.Oanda.V20.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            localVarRequestOptions.PathParameters.Add("instrument", GeriRemenyi.Oanda.V20.Client.ClientUtils.ParameterToString(instrument)); // path parameter
            if (price != null)
            {
                localVarRequestOptions.QueryParameters.Add(GeriRemenyi.Oanda.V20.Client.ClientUtils.ParameterToMultiMap("", "price", price));
            }
            if (granularity != null)
            {
                localVarRequestOptions.QueryParameters.Add(GeriRemenyi.Oanda.V20.Client.ClientUtils.ParameterToMultiMap("", "granularity", granularity));
            }
            if (count != null)
            {
                localVarRequestOptions.QueryParameters.Add(GeriRemenyi.Oanda.V20.Client.ClientUtils.ParameterToMultiMap("", "count", count));
            }
            if (from != null)
            {
                localVarRequestOptions.QueryParameters.Add(GeriRemenyi.Oanda.V20.Client.ClientUtils.ParameterToMultiMap("", "from", from));
            }
            if (to != null)
            {
                localVarRequestOptions.QueryParameters.Add(GeriRemenyi.Oanda.V20.Client.ClientUtils.ParameterToMultiMap("", "to", to));
            }
            if (smooth != null)
            {
                localVarRequestOptions.QueryParameters.Add(GeriRemenyi.Oanda.V20.Client.ClientUtils.ParameterToMultiMap("", "smooth", smooth));
            }
            if (includeFirst != null)
            {
                localVarRequestOptions.QueryParameters.Add(GeriRemenyi.Oanda.V20.Client.ClientUtils.ParameterToMultiMap("", "includeFirst", includeFirst));
            }
            if (dailyAlignment != null)
            {
                localVarRequestOptions.QueryParameters.Add(GeriRemenyi.Oanda.V20.Client.ClientUtils.ParameterToMultiMap("", "dailyAlignment", dailyAlignment));
            }
            if (alignmentTimezone != null)
            {
                localVarRequestOptions.QueryParameters.Add(GeriRemenyi.Oanda.V20.Client.ClientUtils.ParameterToMultiMap("", "alignmentTimezone", alignmentTimezone));
            }
            if (weeklyAlignment != null)
            {
                localVarRequestOptions.QueryParameters.Add(GeriRemenyi.Oanda.V20.Client.ClientUtils.ParameterToMultiMap("", "weeklyAlignment", weeklyAlignment));
            }
            if (acceptDatetimeFormat != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept-Datetime-Format", GeriRemenyi.Oanda.V20.Client.ClientUtils.ParameterToString(acceptDatetimeFormat)); // header parameter
            }

            // authentication (PersonalAccessToken) required
            // bearer authentication required
            if (!String.IsNullOrEmpty(this.Configuration.AccessToken))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", "Bearer " + this.Configuration.AccessToken);
            }

            // make the HTTP request
            var localVarResponse = this.Client.Get< InlineResponse2006 >("/instruments/{instrument}/candles", localVarRequestOptions, this.Configuration);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("InstrumentsInstrumentCandlesGet", localVarResponse);
                if (_exception != null) throw _exception;
            }

            return localVarResponse;
        }

        /// <summary>
        /// Get Candlesticks Fetch candlestick data for an instrument.
        /// </summary>
        /// <exception cref="GeriRemenyi.Oanda.V20.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="instrument">Instrument name</param>
        /// <param name="acceptDatetimeFormat">Format of DateTime fields in the request and response. (optional)</param>
        /// <param name="price">The Price component(s) to get candlestick data for. Can contain any combination of the characters \&quot;M\&quot; (midpoint candles) \&quot;B\&quot; (bid candles) and \&quot;A\&quot; (ask candles). (optional)</param>
        /// <param name="granularity">The granularity of the candlesticks to fetch (optional)</param>
        /// <param name="count">The number of candlesticks to return in the reponse. Count should not be specified if both the start and end parameters are provided, as the time range combined with the graularity will determine the number of candlesticks to return. (optional)</param>
        /// <param name="from">The start of the time range to fetch candlesticks for. (optional)</param>
        /// <param name="to">The end of the time range to fetch candlesticks for. (optional)</param>
        /// <param name="smooth">A flag that controls whether the candlestick is \&quot;smoothed\&quot; or not.  A smoothed candlestick uses the previous candle&#39;s close price as its open price, while an unsmoothed candlestick uses the first price from its time range as its open price. (optional)</param>
        /// <param name="includeFirst">A flag that controls whether the candlestick that is covered by the from time should be included in the results. This flag enables clients to use the timestamp of the last completed candlestick received to poll for future candlesticks but avoid receiving the previous candlestick repeatedly. (optional)</param>
        /// <param name="dailyAlignment">The hour of the day (in the specified timezone) to use for granularities that have daily alignments. (optional)</param>
        /// <param name="alignmentTimezone">The timezone to use for the dailyAlignment parameter. Candlesticks with daily alignment will be aligned to the dailyAlignment hour within the alignmentTimezone.  Note that the returned times will still be represented in UTC. (optional)</param>
        /// <param name="weeklyAlignment">The day of the week used for granularities that have weekly alignment. (optional)</param>
        /// <returns>Task of InlineResponse2006</returns>
        public async System.Threading.Tasks.Task<InlineResponse2006> InstrumentsInstrumentCandlesGetAsync (string instrument, string acceptDatetimeFormat = default(string), string price = default(string), string granularity = default(string), int? count = default(int?), string from = default(string), string to = default(string), bool? smooth = default(bool?), bool? includeFirst = default(bool?), int? dailyAlignment = default(int?), string alignmentTimezone = default(string), string weeklyAlignment = default(string))
        {
             GeriRemenyi.Oanda.V20.Client.ApiResponse<InlineResponse2006> localVarResponse = await InstrumentsInstrumentCandlesGetAsyncWithHttpInfo(instrument, acceptDatetimeFormat, price, granularity, count, from, to, smooth, includeFirst, dailyAlignment, alignmentTimezone, weeklyAlignment);
             return localVarResponse.Data;

        }

        /// <summary>
        /// Get Candlesticks Fetch candlestick data for an instrument.
        /// </summary>
        /// <exception cref="GeriRemenyi.Oanda.V20.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="instrument">Instrument name</param>
        /// <param name="acceptDatetimeFormat">Format of DateTime fields in the request and response. (optional)</param>
        /// <param name="price">The Price component(s) to get candlestick data for. Can contain any combination of the characters \&quot;M\&quot; (midpoint candles) \&quot;B\&quot; (bid candles) and \&quot;A\&quot; (ask candles). (optional)</param>
        /// <param name="granularity">The granularity of the candlesticks to fetch (optional)</param>
        /// <param name="count">The number of candlesticks to return in the reponse. Count should not be specified if both the start and end parameters are provided, as the time range combined with the graularity will determine the number of candlesticks to return. (optional)</param>
        /// <param name="from">The start of the time range to fetch candlesticks for. (optional)</param>
        /// <param name="to">The end of the time range to fetch candlesticks for. (optional)</param>
        /// <param name="smooth">A flag that controls whether the candlestick is \&quot;smoothed\&quot; or not.  A smoothed candlestick uses the previous candle&#39;s close price as its open price, while an unsmoothed candlestick uses the first price from its time range as its open price. (optional)</param>
        /// <param name="includeFirst">A flag that controls whether the candlestick that is covered by the from time should be included in the results. This flag enables clients to use the timestamp of the last completed candlestick received to poll for future candlesticks but avoid receiving the previous candlestick repeatedly. (optional)</param>
        /// <param name="dailyAlignment">The hour of the day (in the specified timezone) to use for granularities that have daily alignments. (optional)</param>
        /// <param name="alignmentTimezone">The timezone to use for the dailyAlignment parameter. Candlesticks with daily alignment will be aligned to the dailyAlignment hour within the alignmentTimezone.  Note that the returned times will still be represented in UTC. (optional)</param>
        /// <param name="weeklyAlignment">The day of the week used for granularities that have weekly alignment. (optional)</param>
        /// <returns>Task of ApiResponse (InlineResponse2006)</returns>
        public async System.Threading.Tasks.Task<GeriRemenyi.Oanda.V20.Client.ApiResponse<InlineResponse2006>> InstrumentsInstrumentCandlesGetAsyncWithHttpInfo (string instrument, string acceptDatetimeFormat = default(string), string price = default(string), string granularity = default(string), int? count = default(int?), string from = default(string), string to = default(string), bool? smooth = default(bool?), bool? includeFirst = default(bool?), int? dailyAlignment = default(int?), string alignmentTimezone = default(string), string weeklyAlignment = default(string))
        {
            // verify the required parameter 'instrument' is set
            if (instrument == null)
                throw new GeriRemenyi.Oanda.V20.Client.ApiException(400, "Missing required parameter 'instrument' when calling InstrumentApi->InstrumentsInstrumentCandlesGet");


            GeriRemenyi.Oanda.V20.Client.RequestOptions localVarRequestOptions = new GeriRemenyi.Oanda.V20.Client.RequestOptions();

            String[] _contentTypes = new String[] {
            };

            // to determine the Accept header
            String[] _accepts = new String[] {
                "application/json"
            };
            
            foreach (var _contentType in _contentTypes)
                localVarRequestOptions.HeaderParameters.Add("Content-Type", _contentType);
            
            foreach (var _accept in _accepts)
                localVarRequestOptions.HeaderParameters.Add("Accept", _accept);
            
            localVarRequestOptions.PathParameters.Add("instrument", GeriRemenyi.Oanda.V20.Client.ClientUtils.ParameterToString(instrument)); // path parameter
            if (price != null)
            {
                localVarRequestOptions.QueryParameters.Add(GeriRemenyi.Oanda.V20.Client.ClientUtils.ParameterToMultiMap("", "price", price));
            }
            if (granularity != null)
            {
                localVarRequestOptions.QueryParameters.Add(GeriRemenyi.Oanda.V20.Client.ClientUtils.ParameterToMultiMap("", "granularity", granularity));
            }
            if (count != null)
            {
                localVarRequestOptions.QueryParameters.Add(GeriRemenyi.Oanda.V20.Client.ClientUtils.ParameterToMultiMap("", "count", count));
            }
            if (from != null)
            {
                localVarRequestOptions.QueryParameters.Add(GeriRemenyi.Oanda.V20.Client.ClientUtils.ParameterToMultiMap("", "from", from));
            }
            if (to != null)
            {
                localVarRequestOptions.QueryParameters.Add(GeriRemenyi.Oanda.V20.Client.ClientUtils.ParameterToMultiMap("", "to", to));
            }
            if (smooth != null)
            {
                localVarRequestOptions.QueryParameters.Add(GeriRemenyi.Oanda.V20.Client.ClientUtils.ParameterToMultiMap("", "smooth", smooth));
            }
            if (includeFirst != null)
            {
                localVarRequestOptions.QueryParameters.Add(GeriRemenyi.Oanda.V20.Client.ClientUtils.ParameterToMultiMap("", "includeFirst", includeFirst));
            }
            if (dailyAlignment != null)
            {
                localVarRequestOptions.QueryParameters.Add(GeriRemenyi.Oanda.V20.Client.ClientUtils.ParameterToMultiMap("", "dailyAlignment", dailyAlignment));
            }
            if (alignmentTimezone != null)
            {
                localVarRequestOptions.QueryParameters.Add(GeriRemenyi.Oanda.V20.Client.ClientUtils.ParameterToMultiMap("", "alignmentTimezone", alignmentTimezone));
            }
            if (weeklyAlignment != null)
            {
                localVarRequestOptions.QueryParameters.Add(GeriRemenyi.Oanda.V20.Client.ClientUtils.ParameterToMultiMap("", "weeklyAlignment", weeklyAlignment));
            }
            if (acceptDatetimeFormat != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept-Datetime-Format", GeriRemenyi.Oanda.V20.Client.ClientUtils.ParameterToString(acceptDatetimeFormat)); // header parameter
            }

            // authentication (PersonalAccessToken) required
            // bearer authentication required
            if (!String.IsNullOrEmpty(this.Configuration.AccessToken))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", "Bearer " + this.Configuration.AccessToken);
            }

            // make the HTTP request

            var localVarResponse = await this.AsynchronousClient.GetAsync<InlineResponse2006>("/instruments/{instrument}/candles", localVarRequestOptions, this.Configuration);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("InstrumentsInstrumentCandlesGet", localVarResponse);
                if (_exception != null) throw _exception;
            }

            return localVarResponse;
        }

        /// <summary>
        /// Get Order Book Fetch an order book for an instrument.
        /// </summary>
        /// <exception cref="GeriRemenyi.Oanda.V20.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="instrument">Instrument name</param>
        /// <param name="acceptDatetimeFormat">Format of DateTime fields in the request and response. (optional)</param>
        /// <param name="time">The time of the snapshot to fetch. If not specified, then the most recent snapshot is fetched. (optional)</param>
        /// <returns>InlineResponse2007</returns>
        public InlineResponse2007 InstrumentsInstrumentOrderBookGet (string instrument, string acceptDatetimeFormat = default(string), string time = default(string))
        {
             GeriRemenyi.Oanda.V20.Client.ApiResponse<InlineResponse2007> localVarResponse = InstrumentsInstrumentOrderBookGetWithHttpInfo(instrument, acceptDatetimeFormat, time);
             return localVarResponse.Data;
        }

        /// <summary>
        /// Get Order Book Fetch an order book for an instrument.
        /// </summary>
        /// <exception cref="GeriRemenyi.Oanda.V20.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="instrument">Instrument name</param>
        /// <param name="acceptDatetimeFormat">Format of DateTime fields in the request and response. (optional)</param>
        /// <param name="time">The time of the snapshot to fetch. If not specified, then the most recent snapshot is fetched. (optional)</param>
        /// <returns>ApiResponse of InlineResponse2007</returns>
        public GeriRemenyi.Oanda.V20.Client.ApiResponse< InlineResponse2007 > InstrumentsInstrumentOrderBookGetWithHttpInfo (string instrument, string acceptDatetimeFormat = default(string), string time = default(string))
        {
            // verify the required parameter 'instrument' is set
            if (instrument == null)
                throw new GeriRemenyi.Oanda.V20.Client.ApiException(400, "Missing required parameter 'instrument' when calling InstrumentApi->InstrumentsInstrumentOrderBookGet");

            GeriRemenyi.Oanda.V20.Client.RequestOptions localVarRequestOptions = new GeriRemenyi.Oanda.V20.Client.RequestOptions();

            String[] _contentTypes = new String[] {
            };

            // to determine the Accept header
            String[] _accepts = new String[] {
                "application/json"
            };

            var localVarContentType = GeriRemenyi.Oanda.V20.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = GeriRemenyi.Oanda.V20.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            localVarRequestOptions.PathParameters.Add("instrument", GeriRemenyi.Oanda.V20.Client.ClientUtils.ParameterToString(instrument)); // path parameter
            if (time != null)
            {
                localVarRequestOptions.QueryParameters.Add(GeriRemenyi.Oanda.V20.Client.ClientUtils.ParameterToMultiMap("", "time", time));
            }
            if (acceptDatetimeFormat != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept-Datetime-Format", GeriRemenyi.Oanda.V20.Client.ClientUtils.ParameterToString(acceptDatetimeFormat)); // header parameter
            }

            // authentication (PersonalAccessToken) required
            // bearer authentication required
            if (!String.IsNullOrEmpty(this.Configuration.AccessToken))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", "Bearer " + this.Configuration.AccessToken);
            }

            // make the HTTP request
            var localVarResponse = this.Client.Get< InlineResponse2007 >("/instruments/{instrument}/orderBook", localVarRequestOptions, this.Configuration);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("InstrumentsInstrumentOrderBookGet", localVarResponse);
                if (_exception != null) throw _exception;
            }

            return localVarResponse;
        }

        /// <summary>
        /// Get Order Book Fetch an order book for an instrument.
        /// </summary>
        /// <exception cref="GeriRemenyi.Oanda.V20.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="instrument">Instrument name</param>
        /// <param name="acceptDatetimeFormat">Format of DateTime fields in the request and response. (optional)</param>
        /// <param name="time">The time of the snapshot to fetch. If not specified, then the most recent snapshot is fetched. (optional)</param>
        /// <returns>Task of InlineResponse2007</returns>
        public async System.Threading.Tasks.Task<InlineResponse2007> InstrumentsInstrumentOrderBookGetAsync (string instrument, string acceptDatetimeFormat = default(string), string time = default(string))
        {
             GeriRemenyi.Oanda.V20.Client.ApiResponse<InlineResponse2007> localVarResponse = await InstrumentsInstrumentOrderBookGetAsyncWithHttpInfo(instrument, acceptDatetimeFormat, time);
             return localVarResponse.Data;

        }

        /// <summary>
        /// Get Order Book Fetch an order book for an instrument.
        /// </summary>
        /// <exception cref="GeriRemenyi.Oanda.V20.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="instrument">Instrument name</param>
        /// <param name="acceptDatetimeFormat">Format of DateTime fields in the request and response. (optional)</param>
        /// <param name="time">The time of the snapshot to fetch. If not specified, then the most recent snapshot is fetched. (optional)</param>
        /// <returns>Task of ApiResponse (InlineResponse2007)</returns>
        public async System.Threading.Tasks.Task<GeriRemenyi.Oanda.V20.Client.ApiResponse<InlineResponse2007>> InstrumentsInstrumentOrderBookGetAsyncWithHttpInfo (string instrument, string acceptDatetimeFormat = default(string), string time = default(string))
        {
            // verify the required parameter 'instrument' is set
            if (instrument == null)
                throw new GeriRemenyi.Oanda.V20.Client.ApiException(400, "Missing required parameter 'instrument' when calling InstrumentApi->InstrumentsInstrumentOrderBookGet");


            GeriRemenyi.Oanda.V20.Client.RequestOptions localVarRequestOptions = new GeriRemenyi.Oanda.V20.Client.RequestOptions();

            String[] _contentTypes = new String[] {
            };

            // to determine the Accept header
            String[] _accepts = new String[] {
                "application/json"
            };
            
            foreach (var _contentType in _contentTypes)
                localVarRequestOptions.HeaderParameters.Add("Content-Type", _contentType);
            
            foreach (var _accept in _accepts)
                localVarRequestOptions.HeaderParameters.Add("Accept", _accept);
            
            localVarRequestOptions.PathParameters.Add("instrument", GeriRemenyi.Oanda.V20.Client.ClientUtils.ParameterToString(instrument)); // path parameter
            if (time != null)
            {
                localVarRequestOptions.QueryParameters.Add(GeriRemenyi.Oanda.V20.Client.ClientUtils.ParameterToMultiMap("", "time", time));
            }
            if (acceptDatetimeFormat != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept-Datetime-Format", GeriRemenyi.Oanda.V20.Client.ClientUtils.ParameterToString(acceptDatetimeFormat)); // header parameter
            }

            // authentication (PersonalAccessToken) required
            // bearer authentication required
            if (!String.IsNullOrEmpty(this.Configuration.AccessToken))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", "Bearer " + this.Configuration.AccessToken);
            }

            // make the HTTP request

            var localVarResponse = await this.AsynchronousClient.GetAsync<InlineResponse2007>("/instruments/{instrument}/orderBook", localVarRequestOptions, this.Configuration);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("InstrumentsInstrumentOrderBookGet", localVarResponse);
                if (_exception != null) throw _exception;
            }

            return localVarResponse;
        }

        /// <summary>
        /// Get Position Book Fetch a position book for an instrument.
        /// </summary>
        /// <exception cref="GeriRemenyi.Oanda.V20.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="instrument">Instrument name</param>
        /// <param name="acceptDatetimeFormat">Format of DateTime fields in the request and response. (optional)</param>
        /// <param name="time">The time of the snapshot to fetch. If not specified, then the most recent snapshot is fetched. (optional)</param>
        /// <returns>InlineResponse2008</returns>
        public InlineResponse2008 InstrumentsInstrumentPositionBookGet (string instrument, string acceptDatetimeFormat = default(string), string time = default(string))
        {
             GeriRemenyi.Oanda.V20.Client.ApiResponse<InlineResponse2008> localVarResponse = InstrumentsInstrumentPositionBookGetWithHttpInfo(instrument, acceptDatetimeFormat, time);
             return localVarResponse.Data;
        }

        /// <summary>
        /// Get Position Book Fetch a position book for an instrument.
        /// </summary>
        /// <exception cref="GeriRemenyi.Oanda.V20.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="instrument">Instrument name</param>
        /// <param name="acceptDatetimeFormat">Format of DateTime fields in the request and response. (optional)</param>
        /// <param name="time">The time of the snapshot to fetch. If not specified, then the most recent snapshot is fetched. (optional)</param>
        /// <returns>ApiResponse of InlineResponse2008</returns>
        public GeriRemenyi.Oanda.V20.Client.ApiResponse< InlineResponse2008 > InstrumentsInstrumentPositionBookGetWithHttpInfo (string instrument, string acceptDatetimeFormat = default(string), string time = default(string))
        {
            // verify the required parameter 'instrument' is set
            if (instrument == null)
                throw new GeriRemenyi.Oanda.V20.Client.ApiException(400, "Missing required parameter 'instrument' when calling InstrumentApi->InstrumentsInstrumentPositionBookGet");

            GeriRemenyi.Oanda.V20.Client.RequestOptions localVarRequestOptions = new GeriRemenyi.Oanda.V20.Client.RequestOptions();

            String[] _contentTypes = new String[] {
            };

            // to determine the Accept header
            String[] _accepts = new String[] {
                "application/json"
            };

            var localVarContentType = GeriRemenyi.Oanda.V20.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = GeriRemenyi.Oanda.V20.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            localVarRequestOptions.PathParameters.Add("instrument", GeriRemenyi.Oanda.V20.Client.ClientUtils.ParameterToString(instrument)); // path parameter
            if (time != null)
            {
                localVarRequestOptions.QueryParameters.Add(GeriRemenyi.Oanda.V20.Client.ClientUtils.ParameterToMultiMap("", "time", time));
            }
            if (acceptDatetimeFormat != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept-Datetime-Format", GeriRemenyi.Oanda.V20.Client.ClientUtils.ParameterToString(acceptDatetimeFormat)); // header parameter
            }

            // authentication (PersonalAccessToken) required
            // bearer authentication required
            if (!String.IsNullOrEmpty(this.Configuration.AccessToken))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", "Bearer " + this.Configuration.AccessToken);
            }

            // make the HTTP request
            var localVarResponse = this.Client.Get< InlineResponse2008 >("/instruments/{instrument}/positionBook", localVarRequestOptions, this.Configuration);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("InstrumentsInstrumentPositionBookGet", localVarResponse);
                if (_exception != null) throw _exception;
            }

            return localVarResponse;
        }

        /// <summary>
        /// Get Position Book Fetch a position book for an instrument.
        /// </summary>
        /// <exception cref="GeriRemenyi.Oanda.V20.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="instrument">Instrument name</param>
        /// <param name="acceptDatetimeFormat">Format of DateTime fields in the request and response. (optional)</param>
        /// <param name="time">The time of the snapshot to fetch. If not specified, then the most recent snapshot is fetched. (optional)</param>
        /// <returns>Task of InlineResponse2008</returns>
        public async System.Threading.Tasks.Task<InlineResponse2008> InstrumentsInstrumentPositionBookGetAsync (string instrument, string acceptDatetimeFormat = default(string), string time = default(string))
        {
             GeriRemenyi.Oanda.V20.Client.ApiResponse<InlineResponse2008> localVarResponse = await InstrumentsInstrumentPositionBookGetAsyncWithHttpInfo(instrument, acceptDatetimeFormat, time);
             return localVarResponse.Data;

        }

        /// <summary>
        /// Get Position Book Fetch a position book for an instrument.
        /// </summary>
        /// <exception cref="GeriRemenyi.Oanda.V20.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="instrument">Instrument name</param>
        /// <param name="acceptDatetimeFormat">Format of DateTime fields in the request and response. (optional)</param>
        /// <param name="time">The time of the snapshot to fetch. If not specified, then the most recent snapshot is fetched. (optional)</param>
        /// <returns>Task of ApiResponse (InlineResponse2008)</returns>
        public async System.Threading.Tasks.Task<GeriRemenyi.Oanda.V20.Client.ApiResponse<InlineResponse2008>> InstrumentsInstrumentPositionBookGetAsyncWithHttpInfo (string instrument, string acceptDatetimeFormat = default(string), string time = default(string))
        {
            // verify the required parameter 'instrument' is set
            if (instrument == null)
                throw new GeriRemenyi.Oanda.V20.Client.ApiException(400, "Missing required parameter 'instrument' when calling InstrumentApi->InstrumentsInstrumentPositionBookGet");


            GeriRemenyi.Oanda.V20.Client.RequestOptions localVarRequestOptions = new GeriRemenyi.Oanda.V20.Client.RequestOptions();

            String[] _contentTypes = new String[] {
            };

            // to determine the Accept header
            String[] _accepts = new String[] {
                "application/json"
            };
            
            foreach (var _contentType in _contentTypes)
                localVarRequestOptions.HeaderParameters.Add("Content-Type", _contentType);
            
            foreach (var _accept in _accepts)
                localVarRequestOptions.HeaderParameters.Add("Accept", _accept);
            
            localVarRequestOptions.PathParameters.Add("instrument", GeriRemenyi.Oanda.V20.Client.ClientUtils.ParameterToString(instrument)); // path parameter
            if (time != null)
            {
                localVarRequestOptions.QueryParameters.Add(GeriRemenyi.Oanda.V20.Client.ClientUtils.ParameterToMultiMap("", "time", time));
            }
            if (acceptDatetimeFormat != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept-Datetime-Format", GeriRemenyi.Oanda.V20.Client.ClientUtils.ParameterToString(acceptDatetimeFormat)); // header parameter
            }

            // authentication (PersonalAccessToken) required
            // bearer authentication required
            if (!String.IsNullOrEmpty(this.Configuration.AccessToken))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", "Bearer " + this.Configuration.AccessToken);
            }

            // make the HTTP request

            var localVarResponse = await this.AsynchronousClient.GetAsync<InlineResponse2008>("/instruments/{instrument}/positionBook", localVarRequestOptions, this.Configuration);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("InstrumentsInstrumentPositionBookGet", localVarResponse);
                if (_exception != null) throw _exception;
            }

            return localVarResponse;
        }

    }
}
